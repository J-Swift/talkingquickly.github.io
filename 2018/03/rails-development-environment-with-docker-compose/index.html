<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>A Rails development environment with Docker</title>
    
        <meta name="description" content="Blog by Ben Dixon, Ruby on Rails Developer, about rails, devops, docker, climbing and startups" />
    


    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google-site-verification" content="iwXSC2H2VSO9iPyrWjNj3Prlx4zJY-l0EJRGVkFuUHk" />


    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />
    <!-- This is for syntax highlight -->
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css">
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <link rel="alternate" type="application/rss+xml" title="RubyFlow"
    href="/rss.xml"/>

</head>
<body class="home-template">


    <main class="content" role="main">

    <article class="post">
        <header class="post-header">
            <a id="blog-logo" href="/"><span class="blog-title">Home</span></a>
            //
            <a target="_blank" href='https://leanpub.com/deploying_rails_applications'>Deploying Rails Book</a>
        </header>

        <span class="post-meta">
        	
       	</span>

        <h1 class="post-title">A Rails development environment with Docker</h1>

        <section class="post-content">
            <p>Docker and Docker Compose reduces bringing up a development environment on any system which supports Docker to a single command. For me this means the time to a working development environment, even on a fresh machine for a project I haven&#39;t worked on for months or years, is just a few seconds.</p>

<!--more-->

<p>This tutorial is not a comprehensive introduction to either Docker or Docker Compose, for this this I highly recomend the <a href="https://docs.docker.com/compose/gettingstarted/">official docker compose tutorial</a> as a starting point. The steps here will stand alone but it&#39;s definitely beneficial to get familiar with the docker-compose fundamentals at some point.</p>

<h2>Installing Docker</h2>

<p>We&#39;ll need to have Docker installed locally <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>. We&#39;ll also need <code>docker-compose</code> installed, for OSX then this is included when installing Docker, for Linux, it must be installed separately and instructions are here; <a href="https://docs.docker.com/compose/install/#install-compose">https://docs.docker.com/compose/install/#install-compose</a>.</p>

<h2>Dockerising a Rails Application</h2>

<p>For an existing Rails application the files below should be added to the root of the project. If generating a new project we should create an empty directory with the name matching the desired name of the Rails project and create the files here. We&#39;ll cover generating the Rails application itself using Docker below.</p>

<p>First we add a file called <code>Dockerfile</code> to the project root which defines how to build the runtime environment for our application:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>FROM ruby:2.4.2
MAINTAINER YOUR_EMAIL

# Install apt based dependencies required to run Rails as
# well as RubyGems. As the Ruby image itself is based on a
# Debian image, we use apt-get to install those.
RUN apt-get update &amp;&amp; apt-get install -y \
  build-essential \
  nodejs


# Configure the main working directory. This is the base
# directory used in any further RUN, COPY, and ENTRYPOINT
# commands.
RUN mkdir -p /app
WORKDIR /app

# Copy the Gemfile as well as the Gemfile.lock and install
# the RubyGems. This is a separate step so the dependencies
# will be cached unless changes to one of those two files
# are made.
COPY Gemfile Gemfile.lock ./
RUN gem install bundler &amp;&amp; bundle install --jobs 20 --retry 5

COPY . /app
RUN rm -rf tmp/*

ADD . /app
</code></pre></div>
<p>Replacing <code>YOUR_EMAIL</code> with your email address.</p>

<p>Then we add a second file called <code>docker-compose.yml</code> to the project root containing the following:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>version: &quot;3&quot;
services:
  app:
    build: .
    command: rails server -p 3000 -b &#39;0.0.0.0&#39;
    volumes:
      - .:/app:delegated
    ports:
      - &quot;3000:3000&quot;
    environment:
      - DB_USERNAME=postgres
      - DB_PASSWORD=postgres
      - DB_HOST=postgres
    depends_on:
      - postgres
      - redis


  postgres:
    image: postgres:9.4
    volumes:
      - postgresdata:/var/lib/postgresql/data
    ports:
      - &quot;5432:5432&quot;

  redis:
    image: redis
    command: redis-server --appendonly yes
    volumes:
      - redisdata:/data
    ports:
      - &quot;6379:6379&quot;

volumes:
  postgresdata:
  redisdata:
</code></pre></div>
<h2>The compose file</h2>

<p>A few elements of this compose file are worth noting as they differ from the many other Rails compose files out there:</p>

<ul>
<li>We don&#39;t use <code>links</code>, these are <a href="https://docs.docker.com/compose/compose-file/#links">no longer the recommended approach</a> for establishing communication between containers. Instead services are available by hostname where the hostname will be the name of the service. E.g. in this case our <code>app</code> conainer can access postgres via the hostname <code>postgres</code> and redis via the hostname <code>redis</code></li>
<li>The <code>:delegated</code> option on the volume mount for our app directory. This is specific to Docker for Mac, although won&#39;t cause problems on other platforms. Details of what this does are <a href="https://docs.docker.com/compose/compose-file/#caching-options-for-volume-mounts-docker-for-mac">available here</a> but it provides a substantial improvement in filesystem performance on OSX, without which day to day development of Rails applications can be painful. If file performance is still not sufficient for your application, it&#39;s worth considering <a href="http://docker-sync.io/">Docker Sync</a> although the 60x slowdown references on that site is substantially reduced by the sue of <code>delegated</code> on OSX</li>
</ul>

<h2>Generating a new application</h2>

<p>When working with an existing Rails application, we can skip this section. Using Docker to generate the entire application is especially useful when trying to maintain no local development environment at all, so we can develop Rails applications without ever needing a local Ruby install.</p>

<p>One of the quickest ways to generate a new Rails application is simply to use the pre-built Bitnami image and execute:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker run --rm -v $(pwd):/app bitnami/rails:latest rails new my_app --database postgresql
</code></pre></div>
<p>Which will pull the Bitnami image and generate a new Rails app called <code>my_app</code> in the current directory.</p>

<p>Alternatively, if you wish to avoid use of a third party image, alongside our <code>Dockerfile</code>, we&#39;ll need to add a <code>Gemfile</code> containing the following:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>source &#39;https://rubygems.org&#39; do
  gem &quot;rails&quot;,
end
</code></pre></div>
<p>and a blank <code>Gemfile.lock</code></p>

<p>Then execute:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker build -t my_rails_image .
docker run --rm -v $(pwd):/app my_rails_image rails new my_app --database postgresql
</code></pre></div>
<p>Which builds an image based on our Dockerfile, tags it with the name <code>my_rails_image</code> and then runs <code>rails new myapp --database postgresql</code> within a container based on that image and creates a new Rails application as a subfolder.</p>

<h2>Dockerising the application</h2>

<p>Our <code>docker-compose.yml</code> file will bring up not only our rails application, but supporting Postgres and Redis instances.</p>

<p>First we&#39;ll make some changes to our Rails application so that all configuration is taken from environment variables. We&#39;ll then update our <code>docker-compose.yml</code> file to set some environment variables. This lays the groundwork for using something like Hashicorp&#39;s <a href="https://github.com/hashicorp/envconsul">envconsul</a> for managing configuration in production at a later date. It&#39;s also a core tenant of building <a href="https://12factor.net/config">12 factor</a> applications.</p>

<p>We&#39;ll begin by modifying <code>config/database.yml</code> to pull connection details from the environment by adding these three lines:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>username: &lt;%= ENV.fetch(&quot;DB_USERNAME&quot;) %&gt;
password: &lt;%= ENV.fetch(&quot;DB_PASSWORD&quot;) %&gt;
host: &lt;%= ENV.fetch(&quot;DB_HOST&quot;) %&gt;
</code></pre></div>
<p>These can either be added to the <code>default</code> section or individually to the <code>development</code> and <code>test</code> sections.</p>

<p>It may look like we could skip this entirely and just use the standard <code>DATABASE_URL</code> environment variable with something like <code>postgres://username:password@postgres/DB_NAME</code> but this will cause problems when running commands such as <code>rake db:migrate</code>. These do not reload environment variables between operating on the test and development databases and therefore raise exceptions when trying to apply migrations to test and development as these will both try and use the same database name.</p>

<p>We can see these map to the values set in the <code>environment</code> section of our <code>app</code> definition in <code>docker-compose.yml</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>services:
  app:
    build: .
    command: rails server -p 3000 -b &#39;0.0.0.0&#39;
    volumes:
      - .:/app:delegated
    ports:
      - &quot;3000:3000&quot;
    environment:
      - DB_USERNAME=postgres
      - DB_PASSWORD=postgres
      - DB_HOST=postgres
</code></pre></div>
<p>The <code>environment</code> section allows us to set up the environment variables which will be set within the container. As discussed above, the <code>postgres</code> service will be available to our container automatically on the hostname <code>postgres</code> which matches the service name in <code>docker-compose.yml</code>. The default credentials for the official postgres image are <code>postgres</code> and <code>postgres</code> and there&#39;s <a href="https://hub.docker.com/_/postgres/">more about customising here</a>.</p>

<p>We can apply the same approach to the <code>config/secrets.yml</code> file if needed as well as anywhere else in the application we want to pass in configuration dynamically. If something like <a href="https://github.com/bkeepers/dotenv">dotenv</a> is in use then we can simply update our local <code>.env</code> file with the above environment variables, rather than defining them in the compose file.</p>

<h2>Starting the rails application</h2>

<p>We can now build the docker image based on our <code>Dockerfile</code> by executing:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose build
</code></pre></div>
<p>Once this is complete we can start our application with:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose up
</code></pre></div>
<p>This will start postgres, redis and our rails application, exposing the rails application on port 3000 so that we can access it by visiting <a href="http://localhost:3000">http://localhost:3000</a> as usual.</p>

<h2>Using with pry</h2>

<p>If we want to use something like <code>pry-rails</code> to debug our rails application, instead of executing <code>docker-compose up</code>, we should use:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run --service-ports app
</code></pre></div>
<h2>Running one off commands</h2>

<p>Usually when setting up a rails application we would run <code>rake db:create</code> and <code>rake db:migrate</code>. If dockerising an existing application, we&#39;re likely to find that we&#39;re greeted with an error page that the database does not exist.</p>

<p>To run one off commands using <code>docker-compose</code> we use the <code>run</code> command in the format:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run SERVICE_NAME CMD
</code></pre></div>
<p>So to run <code>rake db:create db:migrate</code> within the context of our rails application we would use:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run app rake db:migrate db:create
</code></pre></div>
<p>Similarly to start a console we would run:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run app rails console
</code></pre></div>
<p>We could run <code>rspec</code> tests with:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run app rspec spec
</code></pre></div>
<h2>Adding Gems</h2>

<p>When adding new gems, we first update the Gemfile, then execute:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run app bundle
</code></pre></div>
<p>To update the <code>Gemfile.lock</code> and then:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose build
</code></pre></div>
<p>To cache the gems in the image.</p>

<h2>Bash</h2>

<p>We can launch a bash shell in our app container using:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>docker-compose run app bash
</code></pre></div>
<p>It&#39;s important to bear in mind that each invocation of the above runs in a separate, completely isolated, container and so outside the <code>/app</code> directory which is bind mounted to our local directory, the file-systems are transitory and independent of one another.</p>

<p>Being able to run a shell within our app container can be the key to avoiding a lot of frustrating workflow issues when working in a Docker based development environment.</p>

<p>A great example is when upgrading a Rails version. The workflow is typically:</p>

<ul>
<li>Update the version of GEM1 within the <code>Gemfile</code></li>
<li>Execute <code>bundle update GEM1</code></li>
<li>Look to see which dependency issues are raised</li>
<li>Update the <code>Gemfile</code> again</li>
<li>etc etc</li>
</ul>

<p>This can be slow and painful if a separate <code>docker-compose run app ...</code> is required every time. Instead we can use <code>docker-compose run app bash</code> once and then iterate within that container as many times as we want. Once it works we simply jump out of the container and execute <code>docker-compose build</code> to persist the new gems to the image.</p>

<h2>Deploying to production</h2>

<p>Part two covers how to deploy this application to a Kubernetes Cluster on any VPS or Bare Metal provider without having to learn several thousands previously unheard of pieces of terminology.</p>

<p>Feel free to ping me on twitter <a href="https://www.twitter.com/talkingquickly">@TalkingQuickly</a> with any questions or feedback, in particular I&#39;d love to know if a screencast version of this tutorial would be useful?</p>

        </section>

        

        <footer class="post-footer">
          
          
          
            <section class="docker-book">
  <article>
    <h4>Get updates on the series</h4>
    <p>This blog post is part of a 2018 series on using Docker to develop and deploy Rails applications. Currently planned posts include:</p>
    <ul>
      <li>Setting up a private registry</li>
      <li>Production deployment using swarm</li>
      <li>Automatic & Free SSL with LetsEncrypt</li>
      <li>Persistent Storage and database backups</li>
    </ul>
    <p>To get emails when new posts are added, just sign up below.</p>
    <div id="mc_embed_signup">
<form action="http://hillsbede.us5.list-manage.com/subscribe/post?u=68b84d48aa7cec1155bee1a0c&amp;id=73f32eb74a" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" novalidate="">

  <input placeholder="Email Address" type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" style="height:28px;padding: 0 10px 0 10px;">

<input type="submit" value="Get Docker Updates" name="subscribe" id="mc-embedded-subscribe" class="button" style="background-color: #aaa;border: 0 none;border-radius: 4px;color: #FFFFFF;display: inline-block;font-size: 15px;font-weight: bold;height: 32px;line-height: 32px;margin: 0 5px 10px 10px;padding: 0 10px 0 10px;text-align: center;text-decoration: none;vertical-align: top;white-space: nowrap;width: auto;">
</form>
</div>

  </article>
</section>

          


            

        </footer>

    </article>

</main>


    <footer class="site-footer">
        <a class="subscribe icon-feed" href="/rss.xml"><span class="tooltip">Subscribe!</span></a>
        <div class="inner">
          <section class="copyright">All content copyright <a href="/about.html">Ben Dixon</a> &copy; &bull; All rights reserved. Twitter: <a href="http://www.twitter.com/talkingquickly" target="_blank">@talkingquickly</a></section>
             <section class="poweredby">Made with Jekyll and based on the <a href="http://github.com/rosario/kasper" target="_blank">Kasper theme</a></section>
        </div>
    </footer>


    <script type="text/javascript" src="/assets/js/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-7333902-35']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
</body>
</html>
