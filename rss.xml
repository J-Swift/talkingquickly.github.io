<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.7.2">Jekyll</generator>
<link href="https://www.talkingquickly.co.uk/rss.xml" rel="self" type="application/atom+xml" />
<link href="https://www.talkingquickly.co.uk/" rel="alternate" type="text/html" />
<updated>2021-03-25T02:12:30+00:00</updated>
<id>https://www.talkingquickly.co.uk/</id>
<title>talkingquickly</title>
<subtitle>kubernetes, rails, stress free deployment and small steps taken quickly</subtitle>
<author>
<name>Ben Dixon</name>
</author>
<entry>
<title>Managing puma with the systemd user instance and monit</title>
<link href="https://www.talkingquickly.co.uk/managing-puma-with-systemd-user-instance-and-monit" rel="alternate" type="text/html" title="Managing puma with the systemd user instance and monit" />
<published>2021-03-23T15:40:00+00:00</published>
<updated>2021-03-23T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/controlling-puma-with-systemd-userspace-and-monit</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/managing-puma-with-systemd-user-instance-and-monit">&lt;p&gt;Many guides to deploying Rails with Capistrano will use systemd to have it auto-started when the system boots. This is often done using the system instance of systemd which by default can only be controlled by root.&lt;/p&gt;

&lt;p&gt;The typical workaround for this is either to grant our Capistrano deployment user passwordless sudo access or to grant them passwordless sudo access to just the commands required to restart the rails (and potentially sidekiq) systemd services.&lt;/p&gt;

&lt;p&gt;This can be avoided by using the systemd user instance, which allows persistent services to be managed as a non-root user. This is compatible with the default systemd configuration in Ubuntu 20.04.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;There are multiple locations systemd user instance units can be located, there&amp;#39;s more &lt;a href=&quot;https://wiki.archlinux.org/index.php/systemd/User&quot;&gt;here&lt;/a&gt;, in this case we&amp;#39;ll be using: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;~/.config/systemd/user/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In here we&amp;#39;ll put a systemd unit file similar to the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[Unit]
Description=Puma HTTP Server for RAILS APP NAME (ENVIRONMENT)
After=network.target

[Service]
Type=simple

WorkingDirectory=/home/deploy/apps/APP_NAME/current
ExecStart=/usr/local/rbenv/bin/rbenv exec bundle exec puma -C /home/deploy/apps/APP_NAME/shared/puma.rb
ExecReload=/bin/kill -USR1 $MAINPID
ExecStop=/bin/kill -TSTP $MAINPID
StandardOutput=append:/home/deploy/apps/APP_NAME/shared/log/puma_access.log
StandardError=append:/home/deploy/apps/APP_NAME/shared/log/puma_error.log

Environment=RBENV_VERSION=3.0.0
Environment=RBENV_ROOT=/usr/local/rbenv

Restart=always
RestartSec=1

SyslogIdentifier=APP_NAME

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;capistrano-puma&lt;/code&gt; Gem can auto-generate this file and the &lt;code&gt;capistrano-cookbook&lt;/code&gt; gem provides and overridden version of the template which fixes some rbenv compatibility issues and allows for zero downtime deploys (as well as also generating all other capistrano configuration automatically).&lt;/p&gt;

&lt;p&gt;You can see the most recent Capistrano Cookbooks unit file template - which may be useful as a reference - &lt;a href=&quot;https://github.com/TalkingQuickly/capistrano-cookbook/blob/master/lib/generators/capistrano/reliably_deploying_rails/templates/puma.service.erb&quot;&gt;here&lt;/a&gt; which is a tweaked version of the version in &lt;code&gt;capistrano-puma&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note a few things about this unit file:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is no &lt;code&gt;User&lt;/code&gt; directive, user services will run as the user in question, including a &lt;code&gt;User&lt;/code&gt; directive may lead to non-descriptive &lt;code&gt;service start request repeated too quickly, refusing to start&lt;/code&gt; type errors&lt;/li&gt;
&lt;li&gt;Our Environment variables are not included in the &lt;code&gt;ExecStart&lt;/code&gt; command, they&amp;#39;re in separate &lt;code&gt;Environment&lt;/code&gt; lines, &lt;a href=&quot;http://www.talkingquickly.co.uk/capistrano-puma-neither-valid-executable-nor-absolute-path&quot;&gt;this is explained here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WantedBy&lt;/code&gt; is set to &lt;code&gt;default.target&lt;/code&gt; which is the correct value for user services if we want them to be started at boot&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order for our service to be started at boot, we then need to enable this service with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;systemctl --user enable UNIT_FILE_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this is different to starting the unit. We can start a unit immediately with &lt;code&gt;systemctl --user start UNIT_FILE_NAME&lt;/code&gt; but this does not set the unit to be started on boot, so we must enable it as well. This is taken care of automatically if you&amp;#39;re using the &lt;code&gt;deploy:setup_config&lt;/code&gt; task from &lt;code&gt;capistrano-cookbook&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our next challenge is that by default, user instance systemd services are only started when the user starts a session and will continue to run only while the user in question has an active session.&lt;/p&gt;

&lt;p&gt;To resolve this we must enable &lt;a href=&quot;http://manpages.ubuntu.com/manpages/xenial/man1/loginctl.1.html&quot;&gt;lingering&lt;/a&gt;, lingering ensures that a manager for the user in question in spawned on boot so that the user can manage long run services.&lt;/p&gt;

&lt;p&gt;We can enable lingering with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;loginctl enable-linger USERNAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where USERNAME is the capistrano deployment user. This is taken care of automatically if you&amp;#39;re using the &lt;code&gt;deploy:setup_config&lt;/code&gt; task from &lt;code&gt;capistrano-cookbook&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally we may want to monitor our systemd service with Monit. While there is crossover between systemd and monit, both will monitor that a process is running and start it if not.&lt;/p&gt;

&lt;p&gt;Monit however adds some additional capabilities on top of systemd, it can allow for significantly more complex checks such as making sure that our service is responding on a given port and even check the contents of certain healthcheck responses and issuing restarts if these aren&amp;#39;t matched.&lt;/p&gt;

&lt;p&gt;Monit however runs as root and we need it to control a systemd user service.&lt;/p&gt;

&lt;p&gt;We may initially think we can use something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;start program = &amp;quot;/usr/bin/systemctl --user start SYSTEMD_SERVICE_UNIT_FILE&amp;quot; as uid &amp;quot;deploy&amp;quot; and gid &amp;quot;deploy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As our start program where &lt;code&gt;deploy&lt;/code&gt; is our Capistrano user. We might expect this to be equivalent to running &lt;code&gt;systemctl --user start&lt;/code&gt; as the deploy user in a shell. While the command will be run as that user, due to some missing environment variables, we&amp;#39;re likely to get an error along the lines of:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Failed to get D-bus connection: no such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is due to &lt;code&gt;XDG_RUNTIME_DIR&lt;/code&gt; &lt;a href=&quot;https://serverfault.com/questions/936985/cannot-use-systemctl-user-due-to-failed-to-get-d-bus-connection-permission&quot;&gt;not being set correctly&lt;/a&gt; when users are switched in this way. The same issue can happen if we try and use &lt;code&gt;su&lt;/code&gt; in Capistrano to change users before executing a &lt;code&gt;systemctl --user&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;We can resolve is by modifying our start command to set this environment variable manually. So a simple monit definition might look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;check process APP_NAME
  with pidfile &amp;quot;/home/deploy/apps/APP_NAME/shared/tmp/pids/puma.pid&amp;quot;
  start program = &amp;quot;/bin/bash -c &amp;#39;XDG_RUNTIME_DIR=/run/user/$(id -u) /usr/bin/systemctl start --user SYSTEMD_SERVICE_UNIT_FILE&amp;#39;&amp;quot; as uid &amp;quot;deploy&amp;quot; and gid &amp;quot;deploy&amp;quot;
  stop program = &amp;quot;/bin/bash -c &amp;#39;XDG_RUNTIME_DIR=/run/user/$(id -u) /usr/bin/systemctl stop --user SYSTEMD_SERVICE_UNIT_FILE&amp;#39;&amp;quot; as uid &amp;quot;deploy&amp;quot; and gid &amp;quot;deploy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can see the most recent version of &lt;code&gt;capistrano cookbooks&lt;/code&gt; monit definition &lt;a href=&quot;https://github.com/TalkingQuickly/capistrano-cookbook/blob/master/lib/generators/capistrano/reliably_deploying_rails/templates/puma_monit.conf.erb&quot;&gt;here&lt;/a&gt; which may be useful as a reference.&lt;/p&gt;

&lt;p&gt;With all of this completed, we should now have puma being managed by a systemd service, which will auto start at boot, and is monitored with monit.&lt;/p&gt;
</content>
<summary>Many guides to deploying Rails with Capistrano will use systemd to have it auto-started when the system boots. This is often done using the system instance of systemd which by default can only be controlled by root.The typical workaround for this is either to grant our Capistrano deployment user passwordless sudo access or to grant them passwordless sudo access to just the commands required to restart the rails (and potentially sidekiq) systemd services.This can be avoided by using the systemd user instance, which allows persistent services to be managed as a non-root user. This is compatible with the default systemd configuration in Ubuntu 20.04.</summary>
</entry>
<entry>
<title>Capistrano &amp;amp; Puma with Systemd; Permission denied @ rbioreopen</title>
<link href="https://www.talkingquickly.co.uk/capistrano-puma-systemd-permission-denied-@rb_io_repopen" rel="alternate" type="text/html" title="Capistrano &amp; Puma with Systemd; Permission denied @ rb_io_reopen" />
<published>2021-03-16T15:40:00+00:00</published>
<updated>2021-03-16T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/capistrano-puma-permission-denied-rb_io_reopen</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/capistrano-puma-systemd-permission-denied-@rb_io_repopen">&lt;p&gt;When using the capistrano puma gem with systemd, we may get the error:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Permission denied @ rb_io_reopen - /home/deploy/LOG_FILE_PATH/shared/log/puma_access.log (Errno::EACCES)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This may be caused by doubling up on the puma app servers logging.&lt;/p&gt;

&lt;p&gt;Typically our systemd unit will contain something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;StandardOutput=append:/home/deploy/LOG_FILE_PATH/shared/log/puma_access.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which means that any data written to standard output will be appended to the log file specified by systemd.&lt;/p&gt;

&lt;p&gt;If we&amp;#39;re getting the above error, it&amp;#39;s also likely that our &lt;code&gt;puma.rb&lt;/code&gt; configuration file contains something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;stdout_redirect &amp;#39;/home/deploy/LOG_FILE_PATH/shared/log/puma_access.log&amp;#39;, true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which tells puma itself to write to a log file instead of to stdout.&lt;/p&gt;

&lt;p&gt;This doubling up leads to the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;systemd creates the log file as the root user&lt;/li&gt;
&lt;li&gt;puma which we will generally have running as a different user then tries to write to this same file, but it doesn&amp;#39;t have permission because it was created by root&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The solution to this is simple, we can complete remove this line from &lt;code&gt;puma.rb&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;stdout_redirect &amp;#39;/home/deploy/LOG_FILE_PATH/shared/log/puma_access.log&amp;#39;, true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the redirection of stdout is already being handled by systemd.&lt;/p&gt;
</content>
<summary>When using the capistrano puma gem with systemd, we may get the error:Permission denied @ rb_io_reopen - /home/deploy/LOG_FILE_PATH/shared/log/puma_access.log (Errno::EACCES)This may be caused by doubling up on the puma app servers logging.Typically our systemd unit will contain something like:StandardOutput=append:/home/deploy/LOG_FILE_PATH/shared/log/puma_access.logWhich means that any data written to standard output will be appended to the log file specified by systemd.If we&amp;#39;re getting the above error, it&amp;#39;s also likely that our puma.rb configuration file contains something like:stdout_redirect &amp;#39;/home/deploy/LOG_FILE_PATH/shared/log/puma_access.log&amp;#39;, trueWhich tells puma itself to write to a log file instead of to stdout.This doubling up leads to the following:systemd creates the log file as the root userpuma which we will generally have running as a different user then tries to write to this same file, but it doesn&amp;#39;t have permission because it was created by rootThe solution to this is simple, we can complete remove this line from puma.rb:stdout_redirect &amp;#39;/home/deploy/LOG_FILE_PATH/shared/log/puma_access.log&amp;#39;, trueSince the redirection of stdout is already being handled by systemd.</summary>
</entry>
<entry>
<title>Capistrano &amp;amp; Puma; service puma is not active, cannot reload</title>
<link href="https://www.talkingquickly.co.uk/capistrano-puma-is-not-active-cannot-reload" rel="alternate" type="text/html" title="Capistrano &amp; Puma; service puma is not active, cannot reload" />
<published>2021-03-14T15:40:00+00:00</published>
<updated>2021-03-14T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/capistrano-puma-service-not-active-cannot-reload</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/capistrano-puma-is-not-active-cannot-reload">&lt;p&gt;When trying to use the Capistrano Puma gem to restart Puma via systemd, we may run into an error along the lines of:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;puma_APP_NAME.service is not active, cannot reload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This typically happens either because the service was never enabled or because in the time which elapsed between it being enabled and the first deploy taking place, it has crashed a sufficient number of times that it is no longer active.&lt;/p&gt;

&lt;p&gt;The behaviour we want in this scenario is to reload the service if it is active, otherwise to restart it.&lt;/p&gt;

&lt;p&gt;Happily systemctl [supports this out of the box]&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemctl.html&quot;&gt;https://www.freedesktop.org/software/systemd/man/systemctl.html&lt;/a&gt; with &lt;code&gt;systemctl reload-or-restart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can add the following to &lt;code&gt;lib/capistrano/tasks&lt;/code&gt; to add a task which uses this to the puma namespace provided by the capistrano puma gem:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:puma&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:systemd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;Reload the puma service via systemd by sending USR1 (e.g. trigger a zero downtime deploy)&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:reload&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_systemctl_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:system&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_systemctl_bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; reload-or-restart &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_service_unit_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_systemctl_bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;--user&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;reload&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_service_unit_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:loginctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;enable-linger&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_lingering_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:puma_enable_lingering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;deploy:finished&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;puma:systemd:reload&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should be used in conjunction with including the puma systemd tasks in our &lt;code&gt;Capfile&lt;/code&gt; using the &lt;code&gt;load_hooks: false&lt;/code&gt; option which prevents the default restart task from being called.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;install_plugin&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Capistrano&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Puma&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Systemd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;load_hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The use of the above task also allows for zero downtime deploys when used with the relevant puma configuration and systemd unit file. See &lt;a href=&quot;/capistrano-puma-neither-valid-executable-nor-absolute-path&quot;&gt;this post&lt;/a&gt; for more on the systemd unit file and &lt;a href=&quot;https://github.com/TalkingQuickly/rdra_rails6_example&quot;&gt;this repository&lt;/a&gt; for a working example.&lt;/p&gt;
</content>
<summary>When trying to use the Capistrano Puma gem to restart Puma via systemd, we may run into an error along the lines of:puma_APP_NAME.service is not active, cannot reloadThis typically happens either because the service was never enabled or because in the time which elapsed between it being enabled and the first deploy taking place, it has crashed a sufficient number of times that it is no longer active.The behaviour we want in this scenario is to reload the service if it is active, otherwise to restart it.Happily systemctl [supports this out of the box]https://www.freedesktop.org/software/systemd/man/systemctl.html with systemctl reload-or-restart.We can add the following to lib/capistrano/tasks to add a task which uses this to the puma namespace provided by the capistrano puma gem:namespace :puma do  namespace :systemd do    desc &amp;#39;Reload the puma service via systemd by sending USR1 (e.g. trigger a zero downtime deploy)&amp;#39;    task :reload do      on roles(fetch(:puma_role)) do        if fetch(:puma_systemctl_user) == :system          sudo &amp;quot;#{fetch(:puma_systemctl_bin)} reload-or-restart #{fetch(:puma_service_unit_name)}&amp;quot;        else          execute &amp;quot;#{fetch(:puma_systemctl_bin)}&amp;quot;, &amp;quot;--user&amp;quot;, &amp;quot;reload&amp;quot;, fetch(:puma_service_unit_name)          execute :loginctl, &amp;quot;enable-linger&amp;quot;, fetch(:puma_lingering_user) if fetch(:puma_enable_lingering)        end      end    end  endendafter &amp;#39;deploy:finished&amp;#39;, &amp;#39;puma:systemd:reload&amp;#39;This should be used in conjunction with including the puma systemd tasks in our Capfile using the load_hooks: false option which prevents the default restart task from being called.install_plugin Capistrano::Puma::Systemd, load_hooks: falseThe use of the above task also allows for zero downtime deploys when used with the relevant puma configuration and systemd unit file. See this post for more on the systemd unit file and this repository for a working example.</summary>
</entry>
<entry>
<title>Capistrano &amp;amp; Puma; neither a valid executable name nor an absolute path</title>
<link href="https://www.talkingquickly.co.uk/capistrano-puma-neither-valid-executable-nor-absolute-path" rel="alternate" type="text/html" title="Capistrano &amp; Puma; neither a valid executable name nor an absolute path" />
<published>2021-03-14T15:40:00+00:00</published>
<updated>2021-03-14T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/capistrano-puma-neither-a-valid-executable-name-nor-an-absolute-path</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/capistrano-puma-neither-valid-executable-nor-absolute-path">&lt;p&gt;When attempting to deploy a Rails application using the puma web sever using the systemd functionality in the capistrano puma gem, we may receive the error message:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Neither a valid executable name nor an absolute path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When attempting to start the systemd service. This most often occurs when using the capistrano rbenv plugin. This is because the Capistrano rbenv plugin modifies the &lt;code&gt;SSHKit.config.command_map[:bundle]&lt;/code&gt; path to include the &lt;code&gt;RBENV_ROOT&lt;/code&gt; and &lt;code&gt;RBENV_VERSION&lt;/code&gt; environment variables at the start of the &lt;code&gt;bundle&lt;/code&gt; path. Systemd doesn&amp;#39;t support &lt;code&gt;Exec&lt;/code&gt; command starting with environment variables, instead requiring them to be in separate &lt;code&gt;Environment&lt;/code&gt; lines.&lt;/p&gt;

&lt;p&gt;We can fix this by overriding the &lt;code&gt;puma.server.erb&lt;/code&gt; template with a new systemd unit file as follows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;[Unit]
Description=Puma HTTP Server for &amp;lt;%= &amp;quot;#{fetch(:application)} (#{fetch(:stage)})&amp;quot; %&amp;gt;
After=network.target

[Service]
Type=simple
&amp;lt;%=&amp;quot;User=#{puma_user(@role)}&amp;quot; if fetch(:puma_systemctl_user) == :system %&amp;gt;
WorkingDirectory=&amp;lt;%= current_path %&amp;gt;
ExecStart=/usr/local/rbenv/bin/rbenv exec bundle exec puma -C &amp;lt;%= fetch(:puma_conf) %&amp;gt;
ExecReload=/bin/kill -USR1 $MAINPID
ExecStop=/bin/kill -TSTP $MAINPID
StandardOutput=append:&amp;lt;%= fetch(:puma_access_log) %&amp;gt;
StandardError=append:&amp;lt;%= fetch(:puma_error_log) %&amp;gt;
&amp;lt;%=&amp;quot;EnvironmentFile=#{fetch(:puma_service_unit_env_file)}&amp;quot; if fetch(:puma_service_unit_env_file) %&amp;gt;
&amp;lt;% fetch(:puma_service_unit_env_vars, []).each do |environment_variable| %&amp;gt;
&amp;lt;%=&amp;quot;Environment=#{environment_variable}&amp;quot; %&amp;gt;
&amp;lt;% end %&amp;gt;

Environment=RBENV_VERSION=&amp;lt;%= fetch(:rbenv_ruby) %&amp;gt;
Environment=RBENV_ROOT=/usr/local/rbenv

Restart=always
RestartSec=1

SyslogIdentifier=puma_&amp;lt;%= fetch(:application) %&amp;gt;_&amp;lt;%= fetch(:stage) %&amp;gt;

[Install]
WantedBy=&amp;lt;%=(fetch(:puma_systemctl_user) == :system) ? &amp;quot;multi-user.target&amp;quot; : &amp;quot;default.target&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this hardcodes the path to rbenv so if the path is different, for example because it&amp;#39;s a user install not a system install, this will need updating.&lt;/p&gt;

&lt;p&gt;This unit file also adds an &lt;code&gt;ExecReload&lt;/code&gt; option to allow us to use systemd for zero downtime deploys.&lt;/p&gt;

&lt;p&gt;For a fully working example see &lt;a href=&quot;https://github.com/TalkingQuickly/rdra_rails6_example/&quot;&gt;this repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;#39;s more information in &lt;a href=&quot;https://github.com/seuros/capistrano-puma/issues/313&quot;&gt;this github issue&lt;/a&gt;.&lt;/p&gt;
</content>
<summary>When attempting to deploy a Rails application using the puma web sever using the systemd functionality in the capistrano puma gem, we may receive the error message:Neither a valid executable name nor an absolute pathWhen attempting to start the systemd service. This most often occurs when using the capistrano rbenv plugin. This is because the Capistrano rbenv plugin modifies the SSHKit.config.command_map[:bundle] path to include the RBENV_ROOT and RBENV_VERSION environment variables at the start of the bundle path. Systemd doesn&amp;#39;t support Exec command starting with environment variables, instead requiring them to be in separate Environment lines.We can fix this by overriding the puma.server.erb template with a new systemd unit file as follows:[Unit]Description=Puma HTTP Server for &amp;lt;%= &amp;quot;#{fetch(:application)} (#{fetch(:stage)})&amp;quot; %&amp;gt;After=network.target[Service]Type=simple&amp;lt;%=&amp;quot;User=#{puma_user(@role)}&amp;quot; if fetch(:puma_systemctl_user) == :system %&amp;gt;WorkingDirectory=&amp;lt;%= current_path %&amp;gt;ExecStart=/usr/local/rbenv/bin/rbenv exec bundle exec puma -C &amp;lt;%= fetch(:puma_conf) %&amp;gt;ExecReload=/bin/kill -USR1 $MAINPIDExecStop=/bin/kill -TSTP $MAINPIDStandardOutput=append:&amp;lt;%= fetch(:puma_access_log) %&amp;gt;StandardError=append:&amp;lt;%= fetch(:puma_error_log) %&amp;gt;&amp;lt;%=&amp;quot;EnvironmentFile=#{fetch(:puma_service_unit_env_file)}&amp;quot; if fetch(:puma_service_unit_env_file) %&amp;gt;&amp;lt;% fetch(:puma_service_unit_env_vars, []).each do |environment_variable| %&amp;gt;&amp;lt;%=&amp;quot;Environment=#{environment_variable}&amp;quot; %&amp;gt;&amp;lt;% end %&amp;gt;Environment=RBENV_VERSION=&amp;lt;%= fetch(:rbenv_ruby) %&amp;gt;Environment=RBENV_ROOT=/usr/local/rbenvRestart=alwaysRestartSec=1SyslogIdentifier=puma_&amp;lt;%= fetch(:application) %&amp;gt;_&amp;lt;%= fetch(:stage) %&amp;gt;[Install]WantedBy=&amp;lt;%=(fetch(:puma_systemctl_user) == :system) ? &amp;quot;multi-user.target&amp;quot; : &amp;quot;default.target&amp;quot;%&amp;gt;Note that this hardcodes the path to rbenv so if the path is different, for example because it&amp;#39;s a user install not a system install, this will need updating.This unit file also adds an ExecReload option to allow us to use systemd for zero downtime deploys.For a fully working example see this repository.There&amp;#39;s more information in this github issue.</summary>
</entry>
<entry>
<title>Kubernetes Single Sign On - A detailed guide</title>
<link href="https://www.talkingquickly.co.uk/kubernetes-sso-a-detailed-guide" rel="alternate" type="text/html" title="Kubernetes Single Sign On - A detailed guide" />
<published>2021-02-25T15:40:00+00:00</published>
<updated>2021-02-25T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/kubernetes-sso-a-comprehensive-guide</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/kubernetes-sso-a-detailed-guide">&lt;p&gt;In this series of posts we cover how to setup a comprehensive group based single sign on system for Kubernetes including the &lt;code&gt;kubectl&lt;/code&gt; cli, any web application with ingress, a docker registry and gitea. We&amp;#39;ll cover most of the common SSO models so adapting what&amp;#39;s here to other applications such as Gitlab, Kibana, Grafana etc is simple.&lt;/p&gt;

&lt;p&gt;The full solution uses Keycloak backed by OpenLDAP. OpenLDAP is required for the Gitea component, but can be skipped for the other components, including OIDC based SSO for &lt;code&gt;kubectl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some of the highlights this series covers are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Login to the &lt;code&gt;kubectl&lt;/code&gt; cli using SSO credentials via the browser&lt;/li&gt;
&lt;li&gt;Replace basic auth ingress annotations with equally simple but much more secure SSO annotations&lt;/li&gt;
&lt;li&gt;Push and pull to a secure private docker registry with full ACL&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;contents&amp;quot; %}&lt;/p&gt;

&lt;p&gt;Finally there were a lot of excellent resources I leant on when creating this series, there&amp;#39;s a summary of the key ones &lt;a href=&quot;/kubernetes-sso-links&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</content>
<summary>In this series of posts we cover how to setup a comprehensive group based single sign on system for Kubernetes including the kubectl cli, any web application with ingress, a docker registry and gitea. We&amp;#39;ll cover most of the common SSO models so adapting what&amp;#39;s here to other applications such as Gitlab, Kibana, Grafana etc is simple.The full solution uses Keycloak backed by OpenLDAP. OpenLDAP is required for the Gitea component, but can be skipped for the other components, including OIDC based SSO for kubectl.Some of the highlights this series covers are:Login to the kubectl cli using SSO credentials via the browserReplace basic auth ingress annotations with equally simple but much more secure SSO annotationsPush and pull to a secure private docker registry with full ACL        Contents and overview          Installing OpenLDAP          Installing Keycloak          Linking Keycloak and OpenLDAP          OIDC Kubectl Login with Keycloak          Authenticate any web app using ingress annotations          Gitea (requires LDAP)          Simple Docker Registry          Harbor Docker Registry with ACL  Finally there were a lot of excellent resources I leant on when creating this series, there&amp;#39;s a summary of the key ones here.</summary>
</entry>
<entry>
<title>OIDC Login to Kubernetes and Kubectl with Keycloak</title>
<link href="https://www.talkingquickly.co.uk/setting-up-oidc-login-kubernetes-kubectl-with-keycloak" rel="alternate" type="text/html" title="OIDC Login to Kubernetes and Kubectl with Keycloak" />
<published>2021-02-23T15:40:00+00:00</published>
<updated>2021-02-23T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/oidc-login-to-kubernetes-and-kubectl-with-keycloak</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/setting-up-oidc-login-kubernetes-kubectl-with-keycloak">&lt;p&gt;A commonly cited pain point for teams working with Kubernetes clusters is managing the configuration to connect to the cluster. All to often this ends up being either sending KUBECONFIG files with hardcoded credentials back and forth or fragile custom shell scripts wrapping the AWS or GCP cli&amp;#39;s.&lt;/p&gt;

&lt;p&gt;In this post we&amp;#39;ll integrate Kubernetes with Keycloak so that when we execute a &lt;code&gt;kubectl&lt;/code&gt; or &lt;code&gt;helm&lt;/code&gt; command, if the user is not already authenticated, they&amp;#39;ll be presented with a keycloak browser login where they can enter their credentials. No more sharing KUBECONFIG files and forgetting to export different KUBECONFIG paths!&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll also configure group based access control, so we can, for example create a &lt;code&gt;KubernetesAdminstrators&lt;/code&gt; group, and have all users in that group given &lt;code&gt;cluster-admin&lt;/code&gt; access automatically.&lt;/p&gt;

&lt;p&gt;When we remove a user from Keycloak (or remove them from the relevant groups within Keycloak) they will then lose access to the cluster (subject to token expiry).&lt;/p&gt;

&lt;p&gt;For this we&amp;#39;ll be using OpenID Connect, more &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens&quot;&gt;here&lt;/a&gt; on how this works.&lt;/p&gt;

&lt;p&gt;By default, configuring Kubernetes to support OIDC auth requires passing flags to the kubelet API server. The challenge with this approach is that only one such provider can be configured and managed Kubernetes offerings - e.g. GCP or AWS - use this for their proprietary IAM systems.&lt;/p&gt;

&lt;p&gt;To address this we will use &lt;a href=&quot;https://github.com/jetstack/kube-oidc-proxy&quot;&gt;kube-oidc-proxy&lt;/a&gt;, a tool from Jetstack which allows us to connect to a proxy server which will manage OIDC authentication and use impersonation to give the authenticating user the required permissions. This approach has the benefit of being universal across clusters, so we don&amp;#39;t have to follow different approaches for our managed vs unmanaged clusters.&lt;/p&gt;

&lt;p&gt;This post is part of a series on single sign on for Kubernetes.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;kubernetesoidc&amp;quot; %}&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/pre-reqs.html %}&lt;/p&gt;

&lt;p&gt;This also assumes you&amp;#39;ve already followed the Installing Keycloak section and have a functioning Keycloak instance you can login to with administrator rights.&lt;/p&gt;

&lt;h2&gt;Setting up Keycloak&lt;/h2&gt;

&lt;p&gt;First we&amp;#39;ll create a new client in Keycloak with Client ID: &lt;code&gt;kube-oidc-proxy&lt;/code&gt; and client protocol: &lt;code&gt;openid-connect&lt;/code&gt;. We&amp;#39;ll then configure the following parameters for this client:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access Type&lt;/strong&gt;: &lt;code&gt;confidential&lt;/code&gt;, this is required for a client secret to be generated&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Valid Redirect URLs&lt;/strong&gt;: &lt;code&gt;http://localhost:8000&lt;/code&gt; and &lt;code&gt;http://localhost:18000&lt;/code&gt;. This is used by &lt;a href=&quot;https://github.com/int128/kubelogin&quot;&gt;kubelogin&lt;/a&gt; as a callback when we login with &lt;code&gt;kubectl&lt;/code&gt; so a browser window can be opened for us to authenticate with keycloak.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then save this new client and a new &amp;quot;Credentials&amp;quot; tab will appear. We&amp;#39;ll need the generated client secret along with our client id (&lt;code&gt;kube-oidc-proxy&lt;/code&gt;) for later steps.&lt;/p&gt;

&lt;h2&gt;Setting up Kube OIDC Proxy&lt;/h2&gt;

&lt;p&gt;Having created the client, we can now create our configuration for &lt;code&gt;kube-oidc-proxy&lt;/code&gt;. A sample configuration can be found in &lt;code&gt;kube-oidc-proxy/values-kube-oidc.yml&lt;/code&gt; and looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;clientId&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kube-oidc-proxy&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;issuerUrl&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;https://sso.ssotest.staging.talkingquickly.co.uk/auth/realms/master&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;usernameClaim&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;sub&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;extraArgs&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-production&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/backend-protocol&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;HTTPS&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kube.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;/&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc-proxy-tls&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kube.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important things to customise here are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;issuerUrl&lt;/code&gt;, this is the URL of our keycloak instance, including the realm (in this case we&amp;#39;re using the default master realm)&lt;/li&gt;
&lt;li&gt;The hostnames within the ingress definition. This URL will be a second Kubernetes API URL, so once our SSO login is setup, our kubeconfig files will point at this URL instead of the default cluster endpoint&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;extraArgs&lt;/code&gt; &lt;code&gt;v: 10&lt;/code&gt; sets &lt;code&gt;kube-oidc-proxy&lt;/code&gt; to output verbose logging methods which is useful for debugging issues. In production this line can be removed.&lt;/p&gt;

&lt;p&gt;We can then install &lt;code&gt;kube-oidc-proxy&lt;/code&gt; with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm upgrade --install kube-oidc-proxy ./charts/kube-oidc-proxy --values kube-oidc-proxy/values-kube-oidc.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;kube-oidc-proxy&lt;/code&gt; up and running, we can now configure &lt;code&gt;kubectl&lt;/code&gt; to use it. The simplest way to do this is with a &lt;code&gt;kubectl&lt;/code&gt; plugin called &lt;a href=&quot;https://github.com/int128/kubelogin&quot;&gt;kubelogin&lt;/a&gt;. With this plugin installed, when you execute a &lt;code&gt;kubectl&lt;/code&gt; command, it will open a browser window for the user to login via Keycloak. It will then handle refreshing tokens and subsequently re-authorising if the session expires.&lt;/p&gt;

&lt;p&gt;Installation instructions for &lt;code&gt;kubelogin&lt;/code&gt; are &lt;a href=&quot;https://github.com/int128/kubelogin&quot;&gt;here&lt;/a&gt;, if you use homebrew, it&amp;#39;s as simple as &lt;code&gt;brew install int128/kubelogin/kubelogin&lt;/code&gt;, otherwise I recommend &lt;a href=&quot;https://krew.sigs.k8s.io/docs/user-guide/setup/install/&quot;&gt;installing krew&lt;/a&gt; to manage &lt;code&gt;kubectl&lt;/code&gt; plugins which will then allow you to install the plugin with &lt;code&gt;kubectl krew install oidc-login&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll then want to create a &lt;code&gt;kubeconfig.yml&lt;/code&gt; file with the following contents (there&amp;#39;s an example in &lt;code&gt;kubelogin/kuebconfig.yml&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;clusters&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;https://kube.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;default&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;default&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;identity&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;default&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;current-context&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;default&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;Config&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;preferences&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p p-Indicator&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;client.authentication.k8s.io/v1beta1&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc-login&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;get-token&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# - -v1&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;--oidc-issuer-url=https://sso.ssotest.staging.talkingquickly.co.uk/auth/realms/master&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;--oidc-client-id=kube-oidc-proxy&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;--oidc-client-secret=a32807bc-4b5d-40b7-8391-91bb2b80fd30&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;--oidc-extra-scope=email&lt;/span&gt;
      &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;--grant-type=authcode&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kubectl&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;null&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;provideClusterInfo&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replacing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;server&lt;/code&gt; url the ingress url we chose for &lt;code&gt;kube-oidc-proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;oidc-issuer-url&lt;/code&gt; with the same keycloak url we used in the &lt;code&gt;kube-oidc-proxy&lt;/code&gt; configuration&lt;/li&gt;
&lt;li&gt;The value of &lt;code&gt;oidc-client-secret&lt;/code&gt; with the secret key we extracted from the credentials tab of the client in Keycloak&lt;/li&gt;
&lt;li&gt;Optionally uncommenting the &lt;code&gt;-v1&lt;/code&gt; line if you want to see verbose logging output&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then execute &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;export KUBECONFIG=./kubelogin/kubeconfig.yml
kubectl get pods  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Managing your kubeconfig files is beyond the scope of this tutorial but if you aren&amp;#39;t already I strongly recommend some combination of &lt;a href=&quot;https://direnv.net&quot;&gt;direnv&lt;/a&gt; and &lt;a href=&quot;https://github.com/ahmetb/kubectx&quot;&gt;kubectx&lt;/a&gt;. Both my &lt;a href=&quot;/2021/01/debian-dev-environment-for-remote-vscode/&quot;&gt;Debian Remote Dev Env Environment&lt;/a&gt; and &lt;a href=&quot;/2021/01/macos-setup-with-ansible/&quot;&gt;OSX Setup&lt;/a&gt; provide these tools out of the box.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s important to note that the &lt;code&gt;export KUBECONFIG=./kubelogin/kubeconfig.yml&lt;/code&gt; is local to an individual terminal session, so if you switch to a new terminal tab or close and re-open your terminal, it will be gone and you&amp;#39;ll fallback to using whichever &lt;code&gt;KUBECONFIG&lt;/code&gt; envrironment variable your shell is set to use by default.&lt;/p&gt;

&lt;p&gt;When we execute the above we&amp;#39;ll be sent out to a browser to login via Keycloak and once completed we&amp;#39;ll be logged in.&lt;/p&gt;

&lt;p&gt;We will however see an error along the lines of:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Error from server (Forbidden): pods is forbidden: User &amp;quot;oidcuser:7d7c2183-3d96-496a-9516-dda7538854c9&amp;quot; cannot list resource &amp;quot;pods&amp;quot; in API group &amp;quot;&amp;quot; in the namespace &amp;quot;identity&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Although our user is authenticated, e.g. Kubernetes knows that the current user is &lt;code&gt;oidcuser:7d7c2183-3d96-496a-9516-dda7538854c9&lt;/code&gt;, this user is currently not authorised to do anything.&lt;/p&gt;

&lt;p&gt;We can fix this by creating a cluster role binding which binds our user to the &lt;code&gt;cluster-admin&lt;/code&gt; role which is the &amp;quot;superuser&amp;quot; role on Kubernetes.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll need to execute this in a separate temrinal, e.g. one in which we have not run &lt;code&gt;export KUBECONFIG=./kubelogin/kubeconfig.yml&lt;/code&gt; and so &lt;code&gt;KUBECONFIG&lt;/code&gt; is still pointing at a kubeconfig file which gives us &lt;code&gt;cluster-admin&lt;/code&gt; access to the cluster.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;kubectl create clusterrolebinding oidc-cluster-admin --clusterrole=cluster-admin --user=&amp;#39;oidcuser:OUR_USER_ID&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replacing OUR&lt;em&gt;USER&lt;/em&gt;ID with our login users id from Keycloak (or from the error message above).&lt;/p&gt;

&lt;p&gt;Note the &lt;code&gt;oidcuser:&lt;/code&gt; prefix which is added due to the &lt;code&gt;usernamePrefix: &amp;quot;oidcuser:&amp;quot;&lt;/code&gt; prefix configuration line in our Kube OIDC Proxy values file. This prevents users defined in Keycloak from conflicting with any kubernetes internal users.&lt;/p&gt;

&lt;h2&gt;Keycloak login to kubernetes with groups&lt;/h2&gt;

&lt;p&gt;The above setup allows us to use &lt;code&gt;kubectl&lt;/code&gt; while authenticating with our keycloak user. However for each user we have to create an individual cluster role binding assigning them permissions. This is manual and becomes painful for anything beyond a small handful of users.&lt;/p&gt;

&lt;p&gt;The solution to this lies in groups, we&amp;#39;ll configure our kubernetes oidc implementation to be aware of Keycloak groups. We can then create a &lt;code&gt;KubernetesAdmin&lt;/code&gt; group in Keycloak and have all users in this group given &lt;code&gt;cluster-admin&lt;/code&gt; permissions automatically using a single ClusterRoleBinding.&lt;/p&gt;

&lt;p&gt;Begin by creating a &lt;code&gt;KubernetesAdmins&lt;/code&gt; group in Keycloak and then creating a new user and adding them to this group. &lt;/p&gt;

&lt;p&gt;We then need to update our Keycloak client to include the groups the user is a member of as part of the JWT.&lt;/p&gt;

&lt;p&gt;We do this by going back to our &lt;code&gt;kube-oidc-client&lt;/code&gt; entry under Keycloak clients and choosing the mappers tab then &amp;quot;Create&amp;quot;.&lt;/p&gt;

&lt;p&gt;We then enter the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;: &lt;code&gt;Groups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mapper Type&lt;/strong&gt;: &lt;code&gt;Group Membership&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Full Group Path&lt;/strong&gt;: &lt;code&gt;Off&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And then choosing save.&lt;/p&gt;

&lt;p&gt;If we uncomment the &lt;code&gt;# - -v1&lt;/code&gt; line in our &lt;code&gt;kubelogin/kubeconfig.yml&lt;/code&gt; file, remove the contents of &lt;code&gt;~/.kube/cache/oidc-login/&lt;/code&gt; and then execute a &lt;code&gt;kubectl&lt;/code&gt; command e.g. &lt;code&gt;kubectl get pods&lt;/code&gt; then we&amp;#39;ll be asked to login and again and then we&amp;#39;ll see that the decoded JWT now contains our groups, e.g:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;                                         
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;groups&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;                                                       
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;DockerRegistry&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;                                             
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;Administrators&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;KubernetesAdmins&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;             
  &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then create cluster role binding to give anyone with the &lt;code&gt;KubernetesAdmin&lt;/code&gt; group, &lt;code&gt;cluster-admin&lt;/code&gt; access. Our cluster role binding looks like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ClusterRoleBinding&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidc-admin-group&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;roleRef&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ClusterRole&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cluster-admin&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;apiGroup&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;rbac.authorization.k8s.io&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;Group&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oidcgroup:KubernetesAdmins&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;oidcgroup&lt;/code&gt; which is added due to the &lt;code&gt;groupsPrefix: &amp;quot;oidcgroup:&amp;quot;&lt;/code&gt; in our Kube OIDC Proxy values configuration. This prevents keycloak groups from colliding with in-built kubernetes groups.&lt;/p&gt;

&lt;p&gt;We can apply the above with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;kubectl apply -f ./group-auth/cluster-role-binding.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then delete our user specific cluster role binding with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;kubectl delete clusterrolebinding oidc-cluster-admin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can confirm that our groups login works with a simple &lt;code&gt;kubectl get pods&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can take this further by creating more restrictive cluster roles (or using more of the in-built ones) to do things like creating users that only have access to certain namespaces within our cluster.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;kubernetesoidc&amp;quot; %}&lt;/p&gt;
</content>
<summary>A commonly cited pain point for teams working with Kubernetes clusters is managing the configuration to connect to the cluster. All to often this ends up being either sending KUBECONFIG files with hardcoded credentials back and forth or fragile custom shell scripts wrapping the AWS or GCP cli&amp;#39;s.In this post we&amp;#39;ll integrate Kubernetes with Keycloak so that when we execute a kubectl or helm command, if the user is not already authenticated, they&amp;#39;ll be presented with a keycloak browser login where they can enter their credentials. No more sharing KUBECONFIG files and forgetting to export different KUBECONFIG paths!We&amp;#39;ll also configure group based access control, so we can, for example create a KubernetesAdminstrators group, and have all users in that group given cluster-admin access automatically.When we remove a user from Keycloak (or remove them from the relevant groups within Keycloak) they will then lose access to the cluster (subject to token expiry).For this we&amp;#39;ll be using OpenID Connect, more here on how this works.By default, configuring Kubernetes to support OIDC auth requires passing flags to the kubelet API server. The challenge with this approach is that only one such provider can be configured and managed Kubernetes offerings - e.g. GCP or AWS - use this for their proprietary IAM systems.To address this we will use kube-oidc-proxy, a tool from Jetstack which allows us to connect to a proxy server which will manage OIDC authentication and use impersonation to give the authenticating user the required permissions. This approach has the benefit of being universal across clusters, so we don&amp;#39;t have to follow different approaches for our managed vs unmanaged clusters.This post is part of a series on single sign on for Kubernetes.</summary>
</entry>
<entry>
<title>Web application authentication and authorization with Keycloak and OAuth2 Proxy on Kubernetes using Nginx Ingress</title>
<link href="https://www.talkingquickly.co.uk/webapp-authentication-keycloak-OAuth2-proxy-nginx-ingress-kubernetes" rel="alternate" type="text/html" title="Web application authentication and authorization with Keycloak and OAuth2 Proxy on Kubernetes using Nginx Ingress" />
<published>2021-02-21T15:40:00+00:00</published>
<updated>2021-02-21T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/web-application-authentication-with-nginx-keycloak-oauth2-proxy</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/webapp-authentication-keycloak-OAuth2-proxy-nginx-ingress-kubernetes">&lt;p&gt;In this post we&amp;#39;ll setup a generic solution which allows us to add authentication via Keycloak to any application, simply by adding an ingress annotation. This gives us a much more extendable and secure alternative to basic auth.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Many third party applications we run on Kubernetes will already support either OIDC or LDAP based login. Some however will not. In addition we may wish to deploy our own applications and use Keycloak to manage access to them without going through the work of adding OIDC or LDAP integration to them.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll use OAuth2 Proxy to add authentication to a simple nginx container.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll then look at how the application being authenticated can access and decode the Keycloak JSON Web Token and use this for things like group based authorization.&lt;/p&gt;

&lt;p&gt;In it&amp;#39;s simplest form, this would allow us to protect internal admin applications. In a more complete setup, we could setup a &amp;quot;customers&amp;quot; realm within Keycloak and delegate all of our authentication and authorization to Keycloak.&lt;/p&gt;

&lt;p&gt;For this we&amp;#39;ll be using &lt;a href=&quot;https://github.com/oauth2-proxy/oauth2-proxy&quot;&gt;OAuth2 Proxy&lt;/a&gt; which is the &lt;a href=&quot;https://www.keycloak.org/2020/08/sunsetting-louketo-project.adoc&quot;&gt;suggested replacement&lt;/a&gt; for Keycloaks Gatekeeper / Louketo project which reached EOL in August 2020.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;webapps&amp;quot; %}&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/pre-reqs.html %}&lt;/p&gt;

&lt;p&gt;This post assumes you&amp;#39;ve completed the &amp;quot;Installing Keycloak&amp;quot; section and have a working Keycloak installation.&lt;/p&gt;

&lt;h2&gt;Keycloak authentication for an Nginx server&lt;/h2&gt;

&lt;p&gt;First we&amp;#39;ll configure OAuth2 Proxy to work with our Keycloak installation and deploy it using a helm chart. &lt;/p&gt;

&lt;p&gt;Then we&amp;#39;ll deploy the &lt;a href=&quot;https://hub.docker.com/_/nginx&quot;&gt;official Nginx container&lt;/a&gt; image using a helm chart as an example application and then we&amp;#39;ll restrict access to it via Keycloak using ingress annotations.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll then look at how the app we&amp;#39;re authenticating can access information about the logged in user and how this information could be used to implement more fine-grained access control.&lt;/p&gt;

&lt;h2&gt;How it works&lt;/h2&gt;

&lt;p&gt;Nginx supports authentication &lt;a href=&quot;https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/&quot;&gt;based on the result of a sub-request&lt;/a&gt;. This means that when a request comes in for a protected page, it will make a sub-request to an additional URL, if that URL returns any 2xx response code then the request will be allowed, if it returns a 401 or 403 it will be denied.&lt;/p&gt;

&lt;p&gt;In practice we don&amp;#39;t need a deep understanding of the above because OAuth2 Proxy links with keycloak on one side for the actual authentication and provides suitable endpoints for the NGinx to use to check whether a user is authenticated or not.&lt;/p&gt;

&lt;p&gt;So we simple need to configure OAuth2 Proxy and then add suitable ingress annotations to the service we want to protect.&lt;/p&gt;

&lt;h2&gt;Configuring OAuth2 Proxy&lt;/h2&gt;

&lt;p&gt;First we&amp;#39;ll need to create a client application with Keycloak. Crate a new OpenID Connection application and set:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Client ID&lt;/strong&gt;: &lt;code&gt;oauth2-proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Access Type&lt;/strong&gt;: &lt;code&gt;confidential&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Valid Redirect URLs&lt;/strong&gt;:: &lt;code&gt;https://oauth.ssotest.staging.talkingquickly.co.uk/oauth2/callback&lt;/code&gt; replacing &lt;code&gt;oauth.ssotest.staging.talkingquickly.co.uk&lt;/code&gt; with the subdomain you plan to install OAuth2 Proxy on&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You&amp;#39;ll then need to save the entry and go to the newly available &amp;quot;Credentials&amp;quot; tab and make a note of the &amp;quot;Secret&amp;quot;.&lt;/p&gt;

&lt;p&gt;Finally we go to the &amp;quot;Mappers&amp;quot; tab, choose &amp;quot;Create&amp;quot; and select:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;: &lt;code&gt;Groups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mapper Type&lt;/strong&gt;: &lt;code&gt;Group Membership&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token Claim Name&lt;/strong&gt;: &lt;code&gt;groups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All other options &amp;quot;On&amp;quot;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And then choose save. This ensures that the groups the user is a member of are passed back to OAuth2 Proxy and subsequently to the application itself.&lt;/p&gt;

&lt;p&gt;While OAuth2 Proxy does have a &amp;quot;Keycloak&amp;quot; provider, we&amp;#39;re going to use the generic OIDC provider. This is both a more general solution and allows for some additional functionality which is missing the the Keycloak provider, in particular automatic cookie refresh. There is an ongoing discussion within the OAuth2 Proxy team about modifying the Keycloak provider to use the OIDC provider.&lt;/p&gt;

&lt;p&gt;We can then create our configuration for OAuth2 Proxy, an example is included in &lt;code&gt;oauth2-proxy/values-oauth2-proxy.yml&lt;/code&gt; and looks like this:&lt;/p&gt;

&lt;p&gt;@TODO update for OIDC provider 
@TODO update for buffer sizes&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# Oauth client configuration specifics&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;clientID&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;oauth2-proxy&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;clientSecret&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;YOUR_SECRET&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Create a new secret with the following command&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# openssl rand -base64 32 | head -c 32 | base64&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cookieSecret&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;YOUR_COOKIE_SECRET&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;configFile&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p p-Indicator&quot;&gt;|-&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;provider = &amp;quot;oidc&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;provider_display_name = &amp;quot;Keycloak&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;oidc_issuer_url = &amp;quot;YOUR_ISSUER&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;email_domains = [ &amp;quot;*&amp;quot; ]&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;scope = &amp;quot;openid profile email&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;cookie_domain = &amp;quot;.ssotest.staging.talkingquickly.co.uk&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;whitelist_domains = &amp;quot;.ssotest.staging.talkingquickly.co.uk&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;pass_authorization_header = true&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;pass_access_token = true&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;pass_user_headers = true&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;set_authorization_header = true&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;set_xauthrequest = true&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;cookie_refresh = &amp;quot;1m&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;cookie_expire = &amp;quot;30m&amp;quot;&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;/&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oauth.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-production&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/proxy-buffer-size&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;16k&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oauth-proxy-tls&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;oauth.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key fields to update with your own values are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;clientSecret&lt;/strong&gt;: This is the client secret noted down from the Keycloak credentials page&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cookieSecret&lt;/strong&gt;: This can be randomly generated with: &lt;code&gt;openssl rand -base64 32 | head -c 32 | base64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;login&lt;em&gt;url, redeem&lt;/em&gt;url, validate_url&lt;/strong&gt;: which should be updated to match the relevant 
URL&amp;#39;s for your Keycloak installation and realm (in the example above I&amp;#39;m using the master realm)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cookie&lt;em&gt;domain, whitelist&lt;/em&gt;domain&lt;/strong&gt;: which should be updated to match the base URL you&amp;#39;re deploying services on. E.g. in this example configuration I have &lt;code&gt;sso.ssotest.staging.talkingquickly.co.uk&lt;/code&gt;, &lt;code&gt;someapp.ssotest.staging.talkingquickly.co.uk&lt;/code&gt;, &lt;code&gt;oauth.ssotest.staging.talkingquickly.co.uk&lt;/code&gt; etc and so my base domain would be &lt;code&gt;.ssotest.staging.talkingquickly.co.uk&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ingress hosts&lt;/strong&gt;: These should be set the subdomain you wish to deploy OAuth2 Proxy to&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Setting the &lt;code&gt;cookie_domain&lt;/code&gt; and &lt;code&gt;whitelist_domain&lt;/code&gt; is important because by default, OAuth2 Proxy is configured to work only with the subdomain it is deployed on. So cookies will be specific to that subdomain and redirects will only be allowed to that subdomain.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;scope = &amp;quot;openid profile email&amp;quot;&lt;/code&gt; line is important because by default, OAuth2 Proxy will request a scope called &lt;code&gt;api&lt;/code&gt; which does not exist in Keycloak which will result in a 403 Invalid Scopes erorr.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;set_authorization_header&lt;/code&gt; line ensures that the JWT is passed back to the NGinx ingress, this is important because it allows us to then pass this header back to the authenticating application so that it can access more information about the logged in user.&lt;/p&gt;

&lt;p&gt;Finally the &lt;code&gt;nginx.ingress.kubernetes.io/proxy-buffer-size: &amp;quot;16k&amp;quot;&lt;/code&gt; avoids an issue where the large headers which are often passed around with OAuth requests don&amp;#39;t exceed the buffer size in NGinx which leads to errors along the lines of &amp;quot;Cookie &amp;quot;&lt;em&gt;oauth2&lt;/em&gt;proxy&amp;quot; not present&amp;quot; and &amp;quot;upstream sent too big header while reading response header from upstream&amp;quot;.&lt;/p&gt;

&lt;h2&gt;Installing OAuth2 Proxy&lt;/h2&gt;

&lt;p&gt;While we wait for the &lt;code&gt;OAuth2 Proxy&lt;/code&gt; chart to get a new home following the deprecation of the old helm stable repository, the most recent version is mirrored in the example code for this tutorial, so we can install OAuth 2 Proxy with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm upgrade --install oauth2-proxy ./charts/oauth2-proxy --values oauth2-proxy/values-oauth2-proxy.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then go the ingress domain that we selected for OAuth2 Proxy and we will see a &amp;quot;Sign in with Keycloak&amp;quot; option.&lt;/p&gt;

&lt;p&gt;Note that if we are still signed in as the admin user (rather than as a regular user in the realm we configured OAuth2 Proxy with, then we will see something along the lines of 403 Permission Denied, Invalid Account. Incognito / private browsing windows are useful for avoiding this.&lt;/p&gt;

&lt;p&gt;Once we&amp;#39;ve successfully logged in with Keycloak, we&amp;#39;ll simply be re-directed to a 404 page not found error because at the moment, there is nothing to authenticate. In practice we won&amp;#39;t ever go to this URL directly, instead the authentication flow will be triggered automatically by visiting a protected application. So visiting this URL and logging in like this is purely to show that it works.&lt;/p&gt;

&lt;h2&gt;Putting an application behind auth&lt;/h2&gt;

&lt;p&gt;Now that we&amp;#39;ve setup OAuth2 Proxy, we can install an example application and add annotations to the ingress definition to have it protected behind the auth.&lt;/p&gt;

&lt;p&gt;In this example we&amp;#39;re going to simply install an instance of NGINX which serves up the default &amp;quot;Welcome to nginx!&amp;quot; page but require that users login with Keycloak before they can access it. Note that this is completely separate to the &lt;a href=&quot;https://kubernetes.github.io/ingress-nginx/&quot;&gt;NGINX Ingress&lt;/a&gt; that we&amp;#39;re using for Kubernetes.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to be using the bitnami nginx helm chart for this so first we&amp;#39;ll need to add the repo with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We then configure our NGINX demo application along the lines of:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;serverBlock&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p p-Indicator&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;log_format    withauthheaders &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#39;&lt;/span&gt;
                    &lt;span class=&quot;no&quot;&gt;&amp;#39;&amp;quot;$request&amp;quot; $status  $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;#39;&lt;/span&gt;
                    &lt;span class=&quot;no&quot;&gt;&amp;#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &amp;quot;$http_x_auth_request_access_token&amp;quot;&amp;#39;;&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;add_header    x-auth-request-access-token &amp;quot;$http_x_auth_request_access_token&amp;quot;;&lt;/span&gt;

  &lt;span class=&quot;no&quot;&gt;# HTTP Server&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;server {&lt;/span&gt;
      &lt;span class=&quot;no&quot;&gt;# Port to listen on, can also be set in IP:PORT format&lt;/span&gt;
      &lt;span class=&quot;no&quot;&gt;listen  8080;&lt;/span&gt;

      &lt;span class=&quot;no&quot;&gt;include  &amp;quot;/opt/bitnami/nginx/conf/bitnami/*.conf&amp;quot;;&lt;/span&gt;

      &lt;span class=&quot;no&quot;&gt;location /status {&lt;/span&gt;
          &lt;span class=&quot;no&quot;&gt;stub_status on;&lt;/span&gt;
          &lt;span class=&quot;no&quot;&gt;access_log   off;&lt;/span&gt;
          &lt;span class=&quot;no&quot;&gt;allow 127.0.0.1;&lt;/span&gt;
          &lt;span class=&quot;no&quot;&gt;deny all;&lt;/span&gt;
      &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;no&quot;&gt;access_log /dev/stdout withauthheaders;&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx-demo-app2.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-staging&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-url&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;https://oauth.ssotest.staging.talkingquickly.co.uk/oauth2/auth&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-signin&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;https://oauth.ssotest.staging.talkingquickly.co.uk/oauth2/start?rd=$scheme://$best_http_host$request_uri&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-response-headers&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;x-auth-request-user,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;x-auth-request-email,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;x-auth-request-access-token&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;acme.cert-manager.io/http01-edit-in-place&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/proxy-buffer-size&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;16k&amp;quot;&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ClusterIP&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The custom &lt;code&gt;serverBlock&lt;/code&gt; is nothing to do with the actual authentication process. It instead does the following two things to facilitate using NGINX as a demo for the auth functionality:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modifies the logging so that the &lt;code&gt;x-auth-request-access-token&lt;/code&gt; header will be include in log output, this allows us to watch the logs and extract the tokens for analysis and testing&lt;/li&gt;
&lt;li&gt;It automatically appends the &lt;code&gt;x-auth-request-access-token&lt;/code&gt; header from the incoming request to the final user response, so that we can inspect it in the browser&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that especially outputting access tokens to logs is a security risk and should never be done in production.&lt;/p&gt;

&lt;p&gt;The lines associated with the authentication are the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-url&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;https://oauth.ssotest.staging.talkingquickly.co.uk/oauth2/auth&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-signin&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;https://oauth.ssotest.staging.talkingquickly.co.uk/oauth2/start?rd=$scheme://$best_http_host$request_uri&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/auth-response-headers&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;x-auth-request-user,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;x-auth-request-email,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;x-auth-request-access-token&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;acme.cert-manager.io/http01-edit-in-place&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;nginx.ingress.kubernetes.io/proxy-buffer-size&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;16k&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We include &lt;code&gt;acme.cert-manager.io/http01-edit-in-place: &amp;quot;true&amp;quot;&lt;/code&gt; to workaround an issue with Cert Manager and setting auth response headers. We use &lt;code&gt;nginx.ingress.kubernetes.io/proxy-buffer-size: &amp;quot;16k&amp;quot;&lt;/code&gt; to avoid the same buffer size issue with OAuth headers which we described when installing OAuth 2 Proxy.&lt;/p&gt;

&lt;p&gt;The first core line is &lt;code&gt;nginx.ingress.kubernetes.io/auth-url&lt;/code&gt; which specifies the URL which should be used for checking if the current user is authenticated.&lt;/p&gt;

&lt;p&gt;When a request comes in, NGINX auth will first send the request onto this URL, note that it will not send the request body, only the headers, most importantly, any cookies which are associated with the request.&lt;/p&gt;

&lt;p&gt;The service at this URL (in our case OAuth2 Proxy) is responsible for validating, based on any cookies or headers present, whether the user is authenticated.&lt;/p&gt;

&lt;p&gt;If the user is authenticated, then the service returns a 2xx status code, and the request is passed onto our application. If it is not authenticated, then it is passed to the URL specified in &lt;code&gt;nginx.ingress.kubernetes.io/auth-signin&lt;/code&gt; to kick off the authentication flow.&lt;/p&gt;

&lt;p&gt;This is why we had to set the cookie domain of OAuth2 Proxy to explicitly be the base domain, so that the cookie is available on all of the subdomains that we wish to authenticate from.&lt;/p&gt;

&lt;p&gt;Because of the &lt;code&gt;set_authorization_header = true&lt;/code&gt; in our configuration, When a request is authenticated, OAuth2 Proxy will set the &lt;code&gt;x-auth-request-access-token&lt;/code&gt; header on the 2xx response it sends back to NGINX to contain the auth token, in this case a JWT containing information about the user and their session.&lt;/p&gt;

&lt;p&gt;By default, there&amp;#39;s no way for our original application to access this token and if we want our application to know which user is logging in or which groups they are a member of, it will need this information. &lt;/p&gt;

&lt;p&gt;To rectify this, the annotation &lt;code&gt;nginx.ingress.kubernetes.io/auth-response-headers: &amp;quot;x-auth-request-user, x-auth-request-email, x-auth-request-access-token&amp;quot;&lt;/code&gt; instructs the NGINX Ingress to take the listed headers from the returned 2xx response and append them to the response which goes to the backend application.&lt;/p&gt;

&lt;p&gt;Our backend application can then take this header and decode the JWT to gain information about the user.&lt;/p&gt;

&lt;p&gt;In the case of this simple example we simply output it to the logs (insecurely) and append it to the response sent to the user. So if we now go to our Ingress URL for our nginx demo app, in the example case this was https://nginx-demo-app2.ssotest.staging.talkingquickly.co.uk we&amp;#39;ll be asked to login and then redirected to the &amp;quot;Welcome to nginx!&amp;quot; page. &lt;/p&gt;

&lt;p&gt;We can then inspect the request using the network tab in our browser and we&amp;#39;ll see that the &lt;code&gt;x-auth-request-access-token&lt;/code&gt; is set on the response.&lt;/p&gt;

&lt;p&gt;If we copy the value of this header into a decoder such as the one at &lt;a href=&quot;https://jwt.io/&quot;&gt;https://jwt.io/&lt;/a&gt; we&amp;#39;ll see something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;scope&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;openid email profile&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;email_verified&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Ben Dixon&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;groups&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;/DockerRegistry&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;/KubernetesAdmins&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;/Administrators&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;preferred_username&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;talkingquickly&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;given_name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Ben&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;family_name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Dixon&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;quot;email&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;ben@talkingquickly.co.uk&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which in a more complex system, could then be used by our backend application to show different content depending on group membership or surface profile information to the user.&lt;/p&gt;

&lt;h2&gt;Token expiry&lt;/h2&gt;

&lt;p&gt;We effectively have two levels of authentication going on. When a request is first authenticated, OAuth2 Proxy communicates with Keycloak and gets an access token. Going forward when requests come in, as long as the OAuth2 Proxy cookie is present and valid, then the request will not be re-authenticated with Keycloak.&lt;/p&gt;

&lt;p&gt;When working with JSON Web Tokens, this presents a problem because they will typically be issued with an expiry (by default in Keycloak this is 1 minute). This leads to a situation where the user is considered authenticated by OAuth2 Proxy but the JSON web token which is being passed in the &lt;code&gt;x-auth-request-access-token&lt;/code&gt; header is expired. So if we were to then validate this token with our library of choice, we&amp;#39;d receive an exception that the token is invalid.&lt;/p&gt;

&lt;p&gt;The solution of this lies in the following part of the OAuth 2 Proxy configuration file:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;cookie_refresh = &amp;quot;1m&amp;quot;
cookie_expire = &amp;quot;30m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first part &lt;code&gt;cookie_refresh&lt;/code&gt;, instructs OAuth2 Proxy to refresh the access token if the OAuth2 Proxy cookie hasn&amp;#39;t been refreshed for a minute or more. This is aligned with the token expiry set in Keycloak and prevents us from adding stale access tokens to requests. Note that the reason for using the generic OIDC provider in OAuth2 Proxy rather than the specific &amp;quot;Keycloak&amp;quot; one is that the &amp;quot;Keycloak&amp;quot; provider does not (at time of writing) support refresh tokens).&lt;/p&gt;

&lt;p&gt;The second part &lt;code&gt;cookie_expire&lt;/code&gt; instructs OAuth 2 Proxy to expire the cookie if it&amp;#39;s more than 30 minutes old. The user will then be passed back to KeyCloak to re-authenticate. This is again aligned with the default session expiry in Keycloak.&lt;/p&gt;

&lt;h2&gt;Limiting access to certain groups&lt;/h2&gt;

&lt;p&gt;It is possible to crudely limit login to users in particular groups by adding:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;allowed_groups = [&amp;quot;/DemoAdmin&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To the &lt;code&gt;configFile&lt;/code&gt; block in OAuth2 Proxies configuration. This would have the effect of only allowing access if the logged in user was in the &lt;code&gt;DemoAdmin&lt;/code&gt; Keycloak group. It&amp;#39;s worth noting that at time of writing the user experience of this approach is quite poor because the user trying to login will simply see a 500 Internal Server error rather than an informative error message. If we look at the NGinx Ingress logs we&amp;#39;ll see something like &lt;code&gt;auth request unexpected status: 400 while sending to client&lt;/code&gt; which is because OAuth2 Proxy returns a 400 response when the user logs in but is not found to be in one of the allowed groups. &lt;/p&gt;

&lt;p&gt;So while this approach is suitable for simple internal applications, handling group membership within the authenticated application will allow for a more user friendly experience.&lt;/p&gt;

&lt;h2&gt;Working with the token&lt;/h2&gt;

&lt;p&gt;The file &lt;code&gt;jwt-ruby-example/main.rb&lt;/code&gt; contains a simple example of how we could work with this token in a Ruby application. The code itself is very simple:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;jwt&amp;#39;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;public_key_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;PUBLIC_KEY_GOES_HERE&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;public_key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;OpenSSL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RSA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;public_key_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;TOKEN_GOES_HERE&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;decoded_token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;JWT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;public_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;algorithm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;RS256&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decoded_token&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we replace &lt;code&gt;PUBLIC_KEY_GOES_HERE&lt;/code&gt; with the public key which can be found by going to &amp;quot;Realm Settings&amp;quot; and then &amp;quot;Keys&amp;quot; in our Keycloak realm and then choosing &amp;quot;Public Key&amp;quot; for the &lt;code&gt;RS256&lt;/code&gt; entry. &lt;/p&gt;

&lt;p&gt;We then replace &lt;code&gt;TOKEN_GOES_HERE&lt;/code&gt; with a token that we&amp;#39;ve copied from our example apps logs or headers and execute the script with &lt;code&gt;ruby main.rb&lt;/code&gt; (after having run &lt;code&gt;bundle install&lt;/code&gt; etc).&lt;/p&gt;

&lt;p&gt;Note that by default the tokens issued by Keycloak have a 1 minute expiry, so you have to be quick copying and pasting them into this script.&lt;/p&gt;

&lt;p&gt;The output will be the decoded token as a ruby map. So in a full web application (e.g. a Rails or Sinatra app), we could make decisions based on the groups the user is a member of or display to the user their currently logged in email address.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;webapps&amp;quot; %}&lt;/p&gt;
</content>
<summary>In this post we&amp;#39;ll setup a generic solution which allows us to add authentication via Keycloak to any application, simply by adding an ingress annotation. This gives us a much more extendable and secure alternative to basic auth.</summary>
</entry>
<entry>
<title>Comprehensive docker registry on Kubernetes with Harbor and Keycloak for single sign on</title>
<link href="https://www.talkingquickly.co.uk/harbor-docker-registry-on-kubernetes-authentication-with-keycloak" rel="alternate" type="text/html" title="Comprehensive docker registry on Kubernetes with Harbor and Keycloak for single sign on" />
<published>2021-02-19T15:40:00+00:00</published>
<updated>2021-02-19T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/harbour-docker-registry-oidc-keycloak</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/harbor-docker-registry-on-kubernetes-authentication-with-keycloak">&lt;p&gt;In this post we&amp;#39;ll install a feature rich but lightweight docker registry and integrate login and authorization with Keycloak users and groups. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://goharbor.io&quot;&gt;Harbor&lt;/a&gt; is an open source registry which can serve multiple types of cloud artifacts and secure them using fine grained access control. In this case we&amp;#39;ll be focussed on using harbor as a docker image registry and linking it&amp;#39;s authentication with Keycloak but it is also capable of serving multiple other types of artifact, including helm charts.&lt;/p&gt;

&lt;p&gt;This post is part of a series on single sign on for Kubernetes.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;harborregistry&amp;quot; %}&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/pre-reqs.html %}&lt;/p&gt;

&lt;p&gt;This post assumes you&amp;#39;ve already completed the &amp;quot;Installing Keycloak&amp;quot; section.&lt;/p&gt;

&lt;h2&gt;Installing harbor&lt;/h2&gt;

&lt;p&gt;The official helm chart for installing harbor can be found here: &lt;a href=&quot;https://github.com/goharbor/harbor-helm&quot;&gt;https://github.com/goharbor/harbor-helm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As with most helm charts, we learn a lot by inspecting the &lt;a href=&quot;https://github.com/goharbor/harbor-helm/blob/master/values.yaml&quot;&gt;values file which can be found here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this tutorial we&amp;#39;re going to customise the sections which define ingress and TLS certificate generation. OIDC configuration has to be done post installation and can either be done using the HTTP API or the web UI.&lt;/p&gt;

&lt;p&gt;Our initial values file will look something like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;expose&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;certSource&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secret&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;harbor-ingress-tls&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-production&lt;/span&gt;

    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;core.harbor.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;harborAdminPassword&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;85nsafg87ehfgk0fgsgfg6u&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;externalURL&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;https://core.harbor.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretKey&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;8d10dlskeit8fhtg&amp;quot;&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;notary&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;metrics&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Important things to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;certSource: secret&lt;/code&gt; combined with &lt;code&gt;secretName: harbor-ingress-tls&lt;/code&gt; mean that harbor will use the certificate generated for the ingress (by cert manager) rather than generating it&amp;#39;s own certificates. This avoids errors such as &lt;code&gt;x509: certificate signed by unknown authority&lt;/code&gt; when running &lt;code&gt;docker login&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;core:&lt;/code&gt; ingress url should be replaced with the URL you wish Harbour to run on, which should have appropriate DNS records to point it to your NGINX ingress&lt;/li&gt;
&lt;li&gt;&lt;code&gt;harbourAdminPassword&lt;/code&gt;, &lt;code&gt;externalURL&lt;/code&gt; and &lt;code&gt;secretKey&lt;/code&gt; should all be customised with your own values, &lt;code&gt;secretKey&lt;/code&gt; should be a random 16 character value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then add the helm repository and install harbor with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm repo add harbor https://helm.goharbor.io
helm upgrade --install harbor-registry harbor/harbor --values=./harbor/values-harbor.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once this command completes, we&amp;#39;ll be able to access the Harbor UI using the ingress URL we selected for &lt;code&gt;core&lt;/code&gt; with the username &lt;code&gt;admin&lt;/code&gt; and the password we specified in &lt;code&gt;harborAdminPassword&lt;/code&gt;. It takes a while for the various components to start and it&amp;#39;s not unusual to see a few pods in &lt;code&gt;CrashLoopBackoff&lt;/code&gt; temporarily while this is happening.&lt;/p&gt;

&lt;p&gt;Note that we cannot &lt;code&gt;docker login&lt;/code&gt; with our Harbor admin user and we don&amp;#39;t currently have any regular harbor users. We should not create any regular users because we can only switch to OIDC based login if no users other than &lt;code&gt;admin&lt;/code&gt; have been created.&lt;/p&gt;

&lt;p&gt;If we create a test user now and then subsequently delete it, we still won&amp;#39;t be able to switch to OIDC based login. Instead we&amp;#39;ll configure Keycloak login.&lt;/p&gt;

&lt;h2&gt;Creating a client in Keycloak&lt;/h2&gt;

&lt;p&gt;In the KeyCloak clients UI create a new client with Client ID &lt;code&gt;harbor&lt;/code&gt; and Client Protocol &amp;quot;openid-connect&amp;quot; with the following configuration:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access Type&lt;/strong&gt;: &lt;code&gt;confidential&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Valid Redirect URIs&lt;/strong&gt;: &lt;code&gt;https://YOUR_HARBOR_CORE_INGRESS_DOMAIN/c/oidc/callback&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then save the client and make a note of the &amp;quot;Client Secret&amp;quot; in the newly available credentials tab.&lt;/p&gt;

&lt;p&gt;Finally head to the &amp;quot;Mappers&amp;quot; tab for the client and create the following Protocol Mapper:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;: Groups&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mapper Type&lt;/strong&gt;: Group Membership&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token Claim Name&lt;/strong&gt;: &lt;code&gt;groups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Other Options&lt;/strong&gt;: On&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Configuring Harbor OIDC via the admin UI&lt;/h2&gt;

&lt;p&gt;Login to the Harbour web UI available at the ingress URL you selected using the username &lt;code&gt;admin&lt;/code&gt; and the password you specified in &lt;code&gt;harborAdminPassword&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Head to &lt;code&gt;Administration&lt;/code&gt; and then &lt;code&gt;Configuration&lt;/code&gt; and choose the &lt;code&gt;Authentication&lt;/code&gt; tab. Change the &lt;code&gt;Auth Mode&lt;/code&gt; to &lt;code&gt;OIDC&lt;/code&gt; and then enter the following configuration:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OIDC Provider Name&lt;/strong&gt;: Keycloak&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OIDC Endpoint&lt;/strong&gt;: &lt;code&gt;https://YOUR_KEYCLOAK_BASE_URL/auth/realms/YOURREALM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OIDC Client ID&lt;/strong&gt;: &lt;code&gt;harbor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OIDC Client Secret&lt;/strong&gt;: The secret from keycloak clients credentials tab&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Group Claim Name&lt;/strong&gt;: &lt;code&gt;groups&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OIDC Scope&lt;/strong&gt;: &lt;code&gt;openid,profile,email,offline_access&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verify Certificate&lt;/strong&gt;: checked if you&amp;#39;re using a valid SSL cert&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automatic Onboarding&lt;/strong&gt;: checked&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Username Claim&lt;/strong&gt;: &lt;code&gt;preferred_username&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then use the &amp;quot;Test OIDC Server&amp;quot; button to make sure everything is working and once it is, choose &amp;quot;Save&amp;quot;.&lt;/p&gt;

&lt;h2&gt;Testing that it works&lt;/h2&gt;

&lt;p&gt;If we now logout from our admin user (or use a private browsing tab), and return to our Harbor core ingress URL, we now have the option to &amp;quot;Login with OIDC Provider&amp;quot;. If we select this we&amp;#39;ll be redirected to Keycloak to login. Here we should login with a regular Keycloak user from the realm we&amp;#39;re using (by default master), &lt;strong&gt;NOT&lt;/strong&gt; our keycloak admin user.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll then be logged into Harbor and an account automatically created for us based on our Keycloak preferred username.&lt;/p&gt;

&lt;p&gt;If we now log back in as our admin user and go to &amp;quot;Administration&amp;quot; and &amp;quot;Groups&amp;quot; we&amp;#39;ll see that any Keycloak groups the user was a member of have now been replicated into Harbor. This means we can link certain groups to certain projects to automatically give users access to the correct projects.&lt;/p&gt;

&lt;p&gt;Note that by default, all users can create projects. Since all Keycloak users can login to Harbor by default, it may be preferred to limit project creation to admins which can be done by choosing Administration/ Configuration/ System Settings and setting &amp;quot;Project Creation&amp;quot; to Admin Only.&lt;/p&gt;

&lt;p&gt;As an example we can then as an admin user, create a private project called &amp;quot;test1&amp;quot;, then head to the &amp;quot;Members&amp;quot; tab of this project and choose &amp;quot;+ Group&amp;quot;. We can then enter &lt;code&gt;/Administrators&lt;/code&gt; as the Group Name and choose &amp;quot;Project Admin&amp;quot; as the role. Any users in the &lt;code&gt;Administrators&lt;/code&gt; Keycloak group will then automatically be given the &lt;code&gt;Project Admin&lt;/code&gt; role for this project.&lt;/p&gt;

&lt;h2&gt;Use with Docker&lt;/h2&gt;

&lt;p&gt;Assuming we have created the &lt;code&gt;test1&lt;/code&gt; private project above and given our Keycloak master realm user access to it, we can login to the docker registry from our local CLI with the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker login YOUR_HARBOR_CORE_INGRESS_URL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So in my example case this would be:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker login core.harbor.ssotest.staging.talkingquickly.co.uk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then use our keycloak master realm user username. For a password, we should not use our Keycloak password (this won&amp;#39;t work) we should instead obtain our CLI Secret from Harbor by clicking on our username in the top right hand corner, choosing &amp;quot;User Profile&amp;quot; and copying the CLI secret.&lt;/p&gt;

&lt;p&gt;We can then tag an image to be pushed to this repository with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker tag SOURCE_IMAGE[:TAG] core.harbor.ssotest.staging.talkingquickly.co.uk/test1/REPOSITORY[:TAG]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and push it with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker push core.harbor.ssotest.staging.talkingquickly.co.uk/test1/REPOSITORY[:TAG]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we need to give things like CI servers or Kubernetes access to the repository, we can head to the &amp;quot;Robot Accounts&amp;quot; tab in Harbor to generate limited access tokens for exactly this.&lt;/p&gt;

&lt;h2&gt;Configuring Harbor OIDC from the command line&lt;/h2&gt;

&lt;p&gt;In any sort of automated environment (e.g. Ansible, Chef etc) it&amp;#39;s desirable to be able to configure everything without touching the UI. For this Harbor offers a comprehensive API. To view the API documentation login as the admin user and click on the &amp;quot;Habor API V2.0&amp;quot; option at the bottom which will take you to the swagger documentation.&lt;/p&gt;

&lt;p&gt;By default the API will be available on &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;YOUR_INGRESS_URL/api/v2.0/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So for example to view the current configuration we can use:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;curl -u &amp;quot;admin:HARBOR_ADMIN_PASSWORD&amp;quot; -H &amp;quot;Content-Type: application/json&amp;quot; -ki YOUR_INGRESS_URL/api/v2.0/configurations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that at time of writing, the docs at &lt;a href=&quot;https://goharbor.io/docs/1.10/install-config/configure-user-settings-cli/&quot;&gt;https://goharbor.io/docs/1.10/install-config/configure-user-settings-cli/&lt;/a&gt; were slightly behind the current version and while this is the case, getting the existing configuration object provides a better overview of the configuration options available.&lt;/p&gt;

&lt;p&gt;So to set up OIDC auth via CLI we can use:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;curl -X PUT -u &amp;quot;admin:YOUR_ADMIN_PASSWORD&amp;quot; -H &amp;quot;Content-Type: application/json&amp;quot; -ki YOUR_HARBOR_CORE_INGRESS_URL/api/v2.0/configurations -d&amp;#39;{&amp;quot;auth_mode&amp;quot;:&amp;quot;oidc_auth&amp;quot;, &amp;quot;oidc_name&amp;quot;:&amp;quot;Keycloak Auth&amp;quot;, &amp;quot;oidc_endpoint&amp;quot;:&amp;quot;YOUR_KEYCLOAK_REALM_INGRESS&amp;quot;, &amp;quot;oidc_client_id&amp;quot;:&amp;quot;harbor&amp;quot;, &amp;quot;oidc_client_secret&amp;quot;:&amp;quot;YOUR_KEYCLOAK_CLIENT_SECRET&amp;quot;, &amp;quot;oidc_scope&amp;quot;:&amp;quot;openid,profile,email,offline_access&amp;quot;, &amp;quot;oidc_groups_claim&amp;quot;:&amp;quot;groups&amp;quot;, &amp;quot;oidc_auto_onboard&amp;quot;:&amp;quot;true&amp;quot;, &amp;quot;oidc_user_claim&amp;quot;:&amp;quot;preferred_username&amp;quot;}&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A 200 response indicates that we have Succesfully setup Keycloak auth.&lt;/p&gt;

&lt;p&gt;We could then restrict project creation to admins only with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;curl -X PUT -u &amp;quot;admin:YOUR_ADMIN_PASSWORD&amp;quot; -H &amp;quot;Content-Type: application/json&amp;quot; -ki YOUR_HARBOR_CORE_INGRESS_URL/api/v2.0/configurations -d &amp;#39;{&amp;quot;project_creation_restriction&amp;quot;:&amp;quot;adminonly&amp;quot;}&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Habor API is comprehensive e.g. we can also create projects and give groups permission to access these projects entirely via the API so it&amp;#39;s well worth spending time with the Swagger documentation.&lt;/p&gt;

&lt;h2&gt;Use with Kubernetes&lt;/h2&gt;

&lt;p&gt;In order to access images in the registry we&amp;#39;ll need to create appropriate image pull secrets as described &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&quot;&gt;here in the kubernetes documentation&lt;/a&gt; for this we should use project &amp;quot;Robot Tokens&amp;quot;. &lt;/p&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;We now have a self hosted registry for docker images which is fully integrated with Keycloak for authentication. We can also configure this via the command line if we want to automate setup with a configuration management tool such as Chef or Ansible.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;harborregistry&amp;quot; %}&lt;/p&gt;
</content>
<summary>In this post we&amp;#39;ll install a feature rich but lightweight docker registry and integrate login and authorization with Keycloak users and groups. Harbor is an open source registry which can serve multiple types of cloud artifacts and secure them using fine grained access control. In this case we&amp;#39;ll be focussed on using harbor as a docker image registry and linking it&amp;#39;s authentication with Keycloak but it is also capable of serving multiple other types of artifact, including helm charts.This post is part of a series on single sign on for Kubernetes.</summary>
</entry>
<entry>
<title>Docker Registry Authentication on Kubernetes with Keycloak</title>
<link href="https://www.talkingquickly.co.uk/docker-registry-authentication-with-keycloak" rel="alternate" type="text/html" title="Docker Registry Authentication on Kubernetes with Keycloak" />
<published>2021-02-18T15:40:00+00:00</published>
<updated>2021-02-18T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/simple-docker-registry</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/docker-registry-authentication-with-keycloak">&lt;p&gt;In this post we&amp;#39;ll cover how to use Keycloak to provide a simple authentication layer for a Docker registry. Simple meaning that in order to push and pull images to the registry, the user will first need to &lt;code&gt;docker login&lt;/code&gt; as any valid user in the provided Keycloak realm. Note that there is no additional access control, so all Keycloak users have the ability to perform any action on any image once authenticated. For more fine grained controls, see the section on &lt;a href=&quot;/harbor-docker-registry-on-kubernetes-authentication-with-keycloak&quot;&gt;using Harbour&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This post is part of a series on single sign on for Kubernetes.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;dockerregistry&amp;quot; %}&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/pre-reqs.html %}&lt;/p&gt;

&lt;p&gt;This post assumes you&amp;#39;ve already completed the &amp;quot;Installing Keycloak&amp;quot; section.&lt;/p&gt;

&lt;h2&gt;Configuring Keycloak&lt;/h2&gt;

&lt;p&gt;When we configured Keycloak, we included the following in the helm values file:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;-Dkeycloak.profile.feature.docker=enabled&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which enabled the optional support for the Docker registry.&lt;/p&gt;

&lt;h2&gt;Setting up the Docker Registry in Keycloak&lt;/h2&gt;

&lt;p&gt;Begin by creating a new client in Keycloak with client id &amp;quot;simple-docker-registry&amp;quot; using client protocol &lt;code&gt;docker-v2&lt;/code&gt;. On the following screen go to the installation tab, choose &amp;quot;Docker Compose YAML&amp;quot; and select the &amp;quot;Download&amp;quot; option. Note that we aren&amp;#39;t going to be using Docker Compose, but this provides a convenient method for downloading the certificate files we&amp;#39;ll need to create as Kubernetes secrets.&lt;/p&gt;

&lt;h2&gt;Creating the certificate secrets&lt;/h2&gt;

&lt;p&gt;Having downloaded the Docker Compose YAML zip file from Keycloak, extract it to a locally accessible folder and check that it contains a file &lt;code&gt;certs/localhost_trust_chain.pem&lt;/code&gt;. We can then create a Kubernetes secret containing the file with the following:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;kubectl create secret generic docker-registry-auth-token-rootcertbundle --from-file YOUR_PATH_TO/certs/localhost_trust_chain.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replacing &lt;code&gt;YOUR_PATH_TO/certs/localhost_trust_chain.pem&lt;/code&gt; with the path to the downloaded file.&lt;/p&gt;

&lt;p&gt;This will create a secret called &lt;code&gt;docker-registry-auth-token-rootcertbundle&lt;/code&gt; containing the certificate contents.&lt;/p&gt;

&lt;h2&gt;Configuring the docker registry&lt;/h2&gt;

&lt;p&gt;The documentation for the helm chart we&amp;#39;ll be using to install the Docker Registry is here: &lt;a href=&quot;https://github.com/twuni/docker-registry.helm&quot;&gt;https://github.com/twuni/docker-registry.helm&lt;/a&gt;. Our configuration file will look like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;configData&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;realm&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;https://sso.ssotest.staging.talkingquickly.co.uk/auth/realms/master/protocol/docker-v2/auth&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;simple-docker-registry&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;https://sso.ssotest.staging.talkingquickly.co.uk/auth/realms/master&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;rootcertbundle&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;/root-cert-bundle/localhost_trust_chain.pem&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-production&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;registry-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;

  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;registry-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;keycloak-registry-tls-secret&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;extraVolumes&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;docker-registry-auth-token-rootcertbundle&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;docker-registry-auth-token-rootcertbundle&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;extraVolumeMounts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;mountPath&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;/root-cert-bundle&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;docker-registry-auth-token-rootcertbundle&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;configData&lt;/code&gt; section at the top configures the Docker Registry to use token based auth from KeyCloak as per the &lt;a href=&quot;https://www.keycloak.org/docs/4.8/securing_apps/#docker-registry-configuration&quot;&gt;Keycloak Docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You&amp;#39;ll then need to update the ingress definitions to reflect the URL you wish to make your docker registry available on, so replacing &lt;code&gt;registry-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/code&gt; with the subdomain you&amp;#39;ll be using.&lt;/p&gt;

&lt;p&gt;Note that ingress annotation &lt;code&gt;nginx.ingress.kubernetes.io/proxy-body-size: &amp;quot;0&amp;quot;&lt;/code&gt; removes the default limit on the maximum body size NGINX will accept and avoids &lt;code&gt;413 Request Entity Too Large&lt;/code&gt; when pushing large images.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;extraVolumes&lt;/code&gt; section creates a volume which will contain the files from the &lt;code&gt;docker-registry-auth-token-rootcertbundle&lt;/code&gt; secret we created. The &lt;code&gt;extraVolumeMounts&lt;/code&gt; section instructs Kubernetes to mount this volume at the &lt;code&gt;/root-cert-bundle&lt;/code&gt; path within the Docker registry container which matches the &lt;code&gt;rootcertbundle&lt;/code&gt; path that we specified in the &lt;code&gt;configData&lt;/code&gt; map at the start.&lt;/p&gt;

&lt;h2&gt;Installing the Docker Registry&lt;/h2&gt;

&lt;p&gt;We can then add the repository for the helm chart and install the Docker registry with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm repo add twuni https://helm.twun.io
helm upgrade --install simple-docker-registry twuni/docker-registry --values ./docker-registry/values-docker-registry.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Testing the registry&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ll need to give certificates a small window to be generated via LetsEncrypt, we can check on the progress of the certificates with &lt;code&gt;kubectl get certificates&lt;/code&gt;. Once they are ready we can login to our registry with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker login registry-keycloak.ssotest.staging.talkingquickly.co.uk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Replacing the URL with the ingress URL we configured. We can then enter the credentials of any Keycloak user in the realm we configured and we&amp;#39;ll see something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Username: someusername
Password:
WARNING! Your password will be stored unencrypted in /home/ben/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we want to test that pushing images works we can do something like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker image tag SOME_IMAGE_REF registry-keycloak.ssotest.staging.talkingquickly.co.uk/SOME_NAME
docker push registry-keycloak.ssotest.staging.talkingquickly.co.uk/SOME_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And see that the image is pushed correctly.&lt;/p&gt;

&lt;p&gt;We can then test pulling with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker pull registry-keycloak.ssotest.staging.talkingquickly.co.uk/SOME_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We then test that authentication works by logging out with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker logout registry-keycloak.ssotest.staging.talkingquickly.co.uk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And trying to pull the image again:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;docker pull registry-keycloak.ssotest.staging.talkingquickly.co.uk/SOME_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where we&amp;#39;ll receive a permission denied message.&lt;/p&gt;

&lt;h2&gt;Use with Kubernetes&lt;/h2&gt;

&lt;p&gt;In order to access images in the registry we&amp;#39;ll need to create appropriate image pull secrets as described &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&quot;&gt;here in the kubernetes documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;We now have a private Docker Registry which can only be accessed by users authenticated via Keycloak. For more advanced configurations, for example where only certain users should be able to access the registry or where more granular access control is required, see &lt;a href=&quot;/harbor-docker-registry-on-kubernetes-authentication-with-keycloak&quot;&gt;Harbour Docker Registry with Keycloak&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;dockerregistry&amp;quot; %}&lt;/p&gt;
</content>
<summary>In this post we&amp;#39;ll cover how to use Keycloak to provide a simple authentication layer for a Docker registry. Simple meaning that in order to push and pull images to the registry, the user will first need to docker login as any valid user in the provided Keycloak realm. Note that there is no additional access control, so all Keycloak users have the ability to perform any action on any image once authenticated. For more fine grained controls, see the section on using Harbour.This post is part of a series on single sign on for Kubernetes.</summary>
</entry>
<entry>
<title>Gitea SSO with Keycloak, OpenLDAP and OpenID Connect</title>
<link href="https://www.talkingquickly.co.uk/gitea-sso-with-keycloak-openldap-openid-connect" rel="alternate" type="text/html" title="Gitea SSO with Keycloak, OpenLDAP and OpenID Connect" />
<published>2021-02-16T15:40:00+00:00</published>
<updated>2021-02-16T15:40:00+00:00</updated>
<id>https://www.talkingquickly.co.uk/gitea-sso-with-openldap-openidconnect</id>
<content type="html" xml:base="https://www.talkingquickly.co.uk/gitea-sso-with-keycloak-openldap-openid-connect">&lt;p&gt;Gitea is a lightweight open source git service. As an aside, Gitea - especially when combined with Drone CI - is one of my favourite pieces of open source software!&lt;/p&gt;

&lt;p&gt;It&amp;#39;s minimal footprint and easy to use interface make it perfect for running on clusters to facilitate git push deploys and CI.&lt;/p&gt;

&lt;p&gt;Here we&amp;#39;ll configure OpenLDAP for centralised user management and single sign on. We&amp;#39;ll optionally configure OpenID Connect but with several caveats on its usage.&lt;/p&gt;

&lt;p&gt;This post is part of a series on single sign on for Kubernetes.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;gitea&amp;quot; %}&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/pre-reqs.html %}&lt;/p&gt;

&lt;p&gt;This post assumes you&amp;#39;ve completed the &amp;quot;Installing OpenLDAP&amp;quot;, &amp;quot;Installing Keycloak&amp;quot; and &amp;quot;Linking Keycloak and OpenLDAP&amp;quot; sections.&lt;/p&gt;

&lt;h2&gt;Installing Gitea&lt;/h2&gt;

&lt;p&gt;Since we&amp;#39;re primarily concerned with configuring Gitea to use LDAP for authentication, we&amp;#39;ll only cover setting up the web UI here.&lt;/p&gt;

&lt;p&gt;Depending on your cluster configuration, you&amp;#39;ll want to customise &lt;code&gt;gitea/values-gitea.yml&lt;/code&gt; with an ingress address and whether or not SSL should be enabled:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;gitea&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;gitea-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/span&gt; 
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;http&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;installLock&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;false&amp;quot;&lt;/span&gt;

&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;ingress&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;cert-manager.io/cluster-issuer&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;letsencrypt-staging&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;gitea-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
      &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p p-Indicator&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;tls&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;secretName&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;gitea-keycloak-https-secret&lt;/span&gt;
     &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
       &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;gitea-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then install Gitea with:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;helm3 upgrade --install gitea-keycloak ./charts/gitea --values ./gitea/values-gitea.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Gitea should now be available on the chosen Ingress URL, in the example configuration above; &lt;code&gt;gitea-keycloak.ssotest.staging.talkingquickly.co.uk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can then use this command to create an initial user with the username &lt;code&gt;administrator&lt;/code&gt;, by executing the gitea CLI inside its pod. Remember to change &lt;code&gt;YOUR_PASSWORD&lt;/code&gt; and &lt;code&gt;YOUR_EMAIL&lt;/code&gt; to something:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;kubectl exec -it --namespace identity \
      $(kubectl get pods -n identity --selector=&amp;#39;app.kubernetes.io/instance=gitea&amp;#39; -o jsonpath=&amp;#39;{.items[0].metadata.name}&amp;#39;) \
      -- gitea admin user create --username YOUR_EMAIL --password YOUR_PASSWORD --email YOUR_EMAIL --admin --access-token --must-change-password=false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We should then be able to login to our Gitea instance.&lt;/p&gt;

&lt;h2&gt;Configuring Gitea to use LDAP&lt;/h2&gt;

&lt;p&gt;While Gitea does support OIDC login, this is only for existing accounts, so it&amp;#39;s not suitable for centralised user management. So here we&amp;#39;ll be using LDAP.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/go-gitea/gitea/issues/1124?_pjax=%23js-repo-pjax-container#issuecomment-284911694&quot;&gt;This Github Issue&lt;/a&gt; on the Gitea repository explains the difference in behaviour between OIDC and LDAP.&lt;/p&gt;

&lt;p&gt;Begin by logging into Gitea as the &lt;code&gt;administrator&lt;/code&gt; user and going to &amp;quot;Site Administration&amp;quot; and then then &amp;quot;Authentication Sources&amp;quot; tab. Choose &amp;quot;Add Authentication Source&amp;quot; and then select &amp;quot;LDAP (via BindDN)&amp;quot; as the source, select the following values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication Name&lt;/strong&gt;: &lt;code&gt;OpenLDAP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security Protocol&lt;/strong&gt;: &lt;code&gt;Unencrypted&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host&lt;/strong&gt;: &lt;code&gt;openldap.identity.svc.cluster.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Port&lt;/strong&gt;: &lt;code&gt;389&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bind DN&lt;/strong&gt;: &lt;code&gt;cn=readonly,dc=k4stest4,dc=talkingquickly,dc=co,dc=uk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bind Password&lt;/strong&gt;: This should be the password you selected for the read only user in the &lt;code&gt;values-openldap.yml&lt;/code&gt; file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Search Base&lt;/strong&gt;: &lt;code&gt;ou=People,dc=k4stest4,dc=talkingquickly,dc=co,dc=uk&lt;/code&gt; remembering to replace the &lt;code&gt;dc&lt;/code&gt; components with your own&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User Filter&lt;/strong&gt;: &lt;code&gt;(&amp;amp;(objectClass=inetOrgPerson)(uid=%s))&lt;/code&gt; This will allow all users to log into Gitea, you could create a more complex filter that would only let users in certain groups (e.g. &amp;quot;Engineers&amp;quot;) &lt;a href=&quot;https://confluence.atlassian.com/kb/how-to-write-ldap-search-filters-792496933.html&quot;&gt;this article on search filters&lt;/a&gt; has some inspiration on how write these. &lt;code&gt;uid=%s&lt;/code&gt; matches on uid, so people will be able to login with their username, you could modify this filter to match on both email and username.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Username Attribute&lt;/strong&gt;: &lt;code&gt;uid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First Name Attribute&lt;/strong&gt;: &lt;code&gt;cn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Surname attribute&lt;/strong&gt;: &lt;code&gt;sn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Email Attribute&lt;/strong&gt;: &lt;code&gt;mail&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://docs.gitea.io/en-us/authentication/&quot;&gt;Gitea LDAP documentation&lt;/a&gt; provides more detail on what each of these fields does.&lt;/p&gt;

&lt;p&gt;Note that if we&amp;#39;re looking to configure gitea using a configuration management tool, we can use the same approach we used to create the admin user above, to create the LDAP configuration using the CLI as &lt;a href=&quot;https://docs.gitea.io/en-us/command-line/&quot;&gt;documented here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If we now go back to the Gitea sign in page, we&amp;#39;ll find that we can login directly with the credentials for the user we created in Keycloak. Importantly this should be a user we created in the master realm, not our administrative user.&lt;/p&gt;

&lt;p&gt;There&amp;#39;s no re-direction, password authentication is performed behind the scenes. If we go to the security settings for the account, we&amp;#39;ll see that because this user is managed externally, the password cannot be changed from with Gitea, only from within Keycloak.&lt;/p&gt;

&lt;h2&gt;Configuring Gitea to use OpenID Connect&lt;/h2&gt;

&lt;p&gt;While OpenID connect cannot be used for &amp;quot;full&amp;quot; SSO in Gitea, e.g. the underlying users must already exist, it&amp;#39;s possible for users who have already logged in, to configure Keycloak OIDC as an additional login, so that they can go through the Keycloak flow rather than entering their keycloak username and password in Gitea.&lt;/p&gt;

&lt;p&gt;The only real benefit of this approach is that where Keycloak is used extensively, the user may have an ongoing session there, so using that flow to login may be marginally more convenient than entering a username and password. So this option is included for completeness rather than as a typical user case. &lt;/p&gt;

&lt;p&gt;In the Keycloak admin interface, go to &amp;quot;Clients&amp;quot; in the side menu and choose &amp;quot;Create&amp;quot;. Enter gitea for the &lt;code&gt;Client ID&lt;/code&gt; and choose &lt;code&gt;openid-connect&lt;/code&gt; for the &amp;quot;Client Protocol&amp;quot;. Then enter:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;: Gitea&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Access Type&lt;/strong&gt;: &lt;code&gt;confidential&lt;/code&gt; (this is required to generate the client secret)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Valid Redirect URI&amp;#39;s&lt;/strong&gt;: &lt;code&gt;https://GITEA_INGRESS_URL/*&lt;/code&gt; (so in the case of my example above, this would be &lt;code&gt;https://gitea-keycloak.k4stest4.talkingquickly.co.uk/*&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we&amp;#39;ve saved, we can then find the client secret by going back to the &amp;quot;Credentials&amp;quot; tab.&lt;/p&gt;

&lt;p&gt;In gitea go to &amp;quot;Site Administration&amp;quot; and choose &amp;quot;Authentication Sources&amp;quot;. Then choose &amp;quot;Add Authentication Source&amp;quot; and choose the following options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication Type&lt;/strong&gt;: &lt;code&gt;OAuth2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authentication Name&lt;/strong&gt;: &lt;code&gt;Keycloak&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth2 Provider&lt;/strong&gt;: &lt;code&gt;OpenID Connect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Client ID&lt;/strong&gt;: &lt;code&gt;gitea&lt;/code&gt; (the value entered for id when creating the client)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Client Secret&lt;/strong&gt;: &lt;code&gt;YOUR_SECRET&lt;/code&gt; the secret displayed on the credentials tab of the Keycloak Client page for the &lt;code&gt;gitea&lt;/code&gt; client we created&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OpenID Connect Auto Discovery URL&lt;/strong&gt;: &lt;code&gt;https://YOUR_KEYCLOAK_INGRESS_URL/auth/realms/master/.well-known/openid-configuration&lt;/code&gt; replacing &lt;code&gt;YOUR_KEYCLOAK_INGRESS_URL&lt;/code&gt; with the Ingress domain chosen for keycloak. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;#39;s important to note that Gitea will validate the certificate on creation of the provider and will not work without a valid SSL cert.&lt;/p&gt;

&lt;p&gt;Before we try and login, we&amp;#39;ll need to set a password for the user we created in KeyCloak. We can do this by going to the User in Keycloak, choosing the &amp;quot;Credentials&amp;quot; tab and setting a password, if we leave the &amp;quot;Temporary&amp;quot; switch on that page set to 1, then when the user signs in, they&amp;#39;ll be asked to set a new password.&lt;/p&gt;

&lt;p&gt;We can then go to the sign in page in Gitea and click on the &amp;quot;Sign in with OpenID Connect&amp;quot; option (we&amp;#39;ll need to sign out if we&amp;#39;re currently signed in as the administrator user). This will re-direct us the Keycloak login page where we can login with the user we created earlier in Keycloak. &lt;/p&gt;

&lt;p&gt;Once we&amp;#39;ve signed in with our Keycloak credentials, we&amp;#39;ll be re-directed back to Gitea.&lt;/p&gt;

&lt;p&gt;Here we&amp;#39;re asked to enter credentials for an existing user and can enter our keycloak users username and password so that in future we can login using the Keycloak auth flow.&lt;/p&gt;

&lt;p&gt;{% include kubernetes-sso/contents.html active=&amp;quot;gitea&amp;quot; %}&lt;/p&gt;
</content>
<summary>Gitea is a lightweight open source git service. As an aside, Gitea - especially when combined with Drone CI - is one of my favourite pieces of open source software!It&amp;#39;s minimal footprint and easy to use interface make it perfect for running on clusters to facilitate git push deploys and CI.Here we&amp;#39;ll configure OpenLDAP for centralised user management and single sign on. We&amp;#39;ll optionally configure OpenID Connect but with several caveats on its usage.This post is part of a series on single sign on for Kubernetes.</summary>
</entry>
</feed>
